{
  "type": "directory",
  "name": "bucso2_repo",
  "path": ".",
  "children": [
    {
      "type": "directory",
      "name": "src",
      "path": "src",
      "children": []
    },
    {
      "type": "file",
      "name": ".gitignore",
      "path": ".gitignore",
      "size": 109,
      "content_truncated": false,
      "contents": "# Python-generated files\n__pycache__/\n*.py[oc]\nbuild/\ndist/\nwheels/\n*.egg-info\n\n# Virtual environments\n.venv\n",
      "encoding": "utf-8",
      "encoding_error": false
    },
    {
      "type": "file",
      "name": ".python-version",
      "path": ".python-version",
      "size": 5,
      "content_truncated": false,
      "contents": "3.13\n",
      "encoding": "utf-8",
      "encoding_error": false
    },
    {
      "type": "file",
      "name": "buc_diagnostics.py",
      "path": "buc_diagnostics.py",
      "size": 5388,
      "content_truncated": false,
      "contents": "import pandas as pd\r\nimport numpy as np\r\nfrom buc_structures import Tile, FilterModel, LO_Candidate\r\nfrom buc_kernels import get_lut_val\r\n\r\ndef generate_spur_ledger(engine, tile_id, policy_row, if2_filter: FilterModel):\r\n    \"\"\"\r\n    Re-evaluates a specific Tile+LO configuration to generate a detailed list of spurs.\r\n    \"\"\"\r\n    # Retrieve context from engine\r\n    tile = next(t for t in engine.cfg.tiles if t.id == tile_id)\r\n    \r\n    # Reconstruct LO Candidates from policy row\r\n    # Note: We use the engine's generation method to ensure we get the exact same\r\n    # spectral components (harmonics, boundary spurs) as the optimizer saw.\r\n    lo1_freq = policy_row['lo1_hz']\r\n    lo2_freq = policy_row['lo2_hz']\r\n    \r\n    lo1_spec = engine._get_lo_spectrum(engine.hw.lo1_def, lo1_freq)\r\n    lo2_spec = engine._get_lo_spectrum(engine.hw.lo2_def, lo2_freq)\r\n    \r\n    # Determine Mixer Modes based on freq relationships\r\n    # If LO > IF1, it's High Side injection for Stage 1 (usually)\r\n    # We assume the optimization result follows standard Sum/Diff logic\r\n    # Sum: F_out = LO + F_in\r\n    # Diff: F_out = |LO - F_in|\r\n    \r\n    # Heuristic to detect mode from frequencies\r\n    if abs((lo1_freq + tile.if1_center_hz) - if2_filter.center_hz) < 1e6:\r\n        st1_mode = \"SUM\" # F_if2 = LO1 + IF1\r\n    else:\r\n        st1_mode = \"DIFF\" # F_if2 = |LO1 - IF1|\r\n        \r\n    if abs((lo2_freq + if2_filter.center_hz) - tile.rf_center_hz) < 1e6:\r\n        st2_mode = \"SUM\" # F_rf = LO2 + IF2\r\n    else:\r\n        st2_mode = \"DIFF\" # F_rf = |LO2 - IF2|\r\n\r\n    ledger = []\r\n\r\n    # --- Helper to create rows ---\r\n    def add_entry(stage, formula, freq_hz, level_db, limit_db):\r\n        margin = limit_db - level_db - engine.cfg.yaml_data['constraints']['guard_margin_db']\r\n        ledger.append({\r\n            \"Stage\": stage,\r\n            \"Formula\": formula,\r\n            \"Freq_GHz\": freq_hz / 1e9,\r\n            \"Level_dBm_equiv\": level_db, # Actually dBc relative to carrier, loosely\r\n            \"Limit_dBc\": limit_db,\r\n            \"Margin_dB\": margin\r\n        })\r\n\r\n    # --- STAGE 1 ANALYSIS ---\r\n    # Desired IF2\r\n    f_if2_desired = if2_filter.center_hz\r\n    \r\n    for k in range(len(lo1_spec)):\r\n        f_lo_c = lo1_spec[k, 0]\r\n        p_lo_c = lo1_spec[k, 1]\r\n        \r\n        for row in engine.hw.mixer1.spur_table_np:\r\n            m, n, rej = int(row[0]), int(row[1]), row[2]\r\n            \r\n            for s_lo in [-1, 1]:\r\n                for s_if in [-1, 1]:\r\n                    # Spur Freq at IF2\r\n                    f_spur_if2 = abs(s_lo * m * f_lo_c + s_if * n * tile.if1_center_hz)\r\n                    \r\n                    # Skip Desired\r\n                    if k==0 and m==1 and n==1 and abs(f_spur_if2 - f_if2_desired) < 1000:\r\n                        continue\r\n\r\n                    # Level at Mixer Output\r\n                    lvl = p_lo_c + rej\r\n                    \r\n                    # IF2 Filter Attenuation (Re-calc using LUT utility)\r\n                    atten_if2 = get_lut_val(f_spur_if2, engine.if2_lut_buffer, engine.grid_step)\r\n                    lvl -= atten_if2\r\n                    \r\n                    if lvl < -100: continue\r\n                    \r\n                    # Map to RF via Desired Stage 2 Path\r\n                    if st2_mode == \"SUM\":\r\n                        f_rf_equiv = lo2_freq + f_spur_if2\r\n                    else:\r\n                        f_rf_equiv = abs(lo2_freq - f_spur_if2)\r\n                    \r\n                    # RF Filter\r\n                    atten_rf = get_lut_val(f_rf_equiv, engine.rf_lut, engine.grid_step)\r\n                    lvl -= atten_rf\r\n                    \r\n                    # Mask\r\n                    limit = get_lut_val(f_rf_equiv, engine.mask_lut, engine.grid_step)\r\n                    \r\n                    if (limit - lvl) < 10.0: # Only log significant spurs\r\n                        formula = f\"({m}*LO1{'H' if k>0 else ''} {s_lo:+} {n}*IF1 {s_if:+})\"\r\n                        add_entry(1, formula, f_rf_equiv, lvl, limit)\r\n\r\n    # --- STAGE 2 ANALYSIS ---\r\n    for k in range(len(lo2_spec)):\r\n        f_lo_c = lo2_spec[k, 0]\r\n        p_lo_c = lo2_spec[k, 1]\r\n        \r\n        for row in engine.hw.mixer2.spur_table_np:\r\n            m, n, rej = int(row[0]), int(row[1]), row[2]\r\n            \r\n            for s_lo in [-1, 1]:\r\n                for s_if in [-1, 1]:\r\n                    # Spur Freq at RF\r\n                    f_spur_rf = abs(s_lo * m * f_lo_c + s_if * n * f_if2_desired)\r\n                    \r\n                    if k==0 and m==1 and n==1 and abs(f_spur_rf - tile.rf_center_hz) < 1000:\r\n                        continue\r\n                        \r\n                    lvl = p_lo_c + rej\r\n                    \r\n                    atten_rf = get_lut_val(f_spur_rf, engine.rf_lut, engine.grid_step)\r\n                    lvl -= atten_rf\r\n                    \r\n                    if lvl < -100: continue\r\n                    \r\n                    limit = get_lut_val(f_spur_rf, engine.mask_lut, engine.grid_step)\r\n                    \r\n                    if (limit - lvl) < 10.0:\r\n                        formula = f\"({m}*LO2{'H' if k>0 else ''} {s_lo:+} {n}*IF2 {s_if:+})\"\r\n                        add_entry(2, formula, f_spur_rf, lvl, limit)\r\n\r\n    df = pd.DataFrame(ledger)\r\n    if not df.empty:\r\n        df = df.sort_values(\"Margin_dB\", ascending=True)\r\n    return df",
      "encoding": "utf-8",
      "encoding_error": false
    },
    {
      "type": "file",
      "name": "buc_engine.py",
      "path": "buc_engine.py",
      "size": 8822,
      "content_truncated": false,
      "contents": "import numpy as np\r\nfrom buc_structures import Tile, FilterModel, LO_Candidate\r\nfrom buc_kernels import (\r\n    build_dense_lut, \r\n    fill_symmetric_filter_lut, \r\n    fill_scaled_s2p_lut,\r\n    compute_stage1_intermediates,\r\n    compute_stage2_from_intermediates\r\n)\r\n\r\nclass SpurEngine:\r\n    def __init__(self, config, hw_stack):\r\n        self.cfg = config\r\n        self.hw = hw_stack\r\n        \r\n        # 1. Build Global Grids and Static LUTs\r\n        print(\"  Building Global LUTs...\")\r\n        self.grid_max = self.cfg.grid_max_freq_hz\r\n        self.grid_step = self.cfg.grid_step_hz\r\n        self.opt_cutoff = self.cfg.opt_cutoff_db\r\n        self.noise_floor = self.cfg.noise_floor_dbc\r\n        self.guard_db = float(self.cfg.yaml_data['constraints']['guard_margin_db'])\r\n        \r\n        # Mask LUT (In-band + Out-of-band)\r\n        mask_oob_def = self.cfg.yaml_data['masks']['outofband']['default_dbc']\r\n        self.mask_lut = np.full(int(self.grid_max/self.grid_step)+1, mask_oob_def, dtype=np.float32)\r\n        \r\n        ib_cfg = self.cfg.yaml_data['masks']['inband']\r\n        rf_min = self.cfg.yaml_data['bands']['rf_hz']['min']\r\n        rf_max = self.cfg.yaml_data['bands']['rf_hz']['max']\r\n        \r\n        idx_min = int(rf_min / self.grid_step)\r\n        idx_max = int(rf_max / self.grid_step)\r\n        self.mask_lut[idx_min:idx_max] = float(ib_cfg['default_dbc'])\r\n        \r\n        # RF Filter LUT\r\n        self.rf_lut = build_dense_lut(\r\n            self.cfg.rf_filter_raw_freqs,\r\n            self.cfg.rf_filter_raw_atten,\r\n            self.grid_max, self.grid_step, 80.0\r\n        )\r\n        \r\n        # Pre-allocate IF2 LUT\r\n        self.if2_lut_buffer = np.zeros_like(self.rf_lut)\r\n        \r\n        # LO Spectrum Cache\r\n        self.lo_cache = {} \r\n\r\n    def _get_lo_spectrum(self, lo_def, freq):\r\n        key = (freq, lo_def.name)\r\n        if key not in self.lo_cache:\r\n            self.lo_cache[key] = self.hw.generate_lo_spectrum(lo_def, freq)\r\n        return self.lo_cache[key]\r\n\r\n    def evaluate_policy(self, if2_filter: FilterModel, search_mode=True):\r\n        \"\"\" Evaluate the entire policy for a fixed IF2 filter. \"\"\"\r\n        worst_margin = 999.0\r\n        \r\n        # 1. Build IF2 LUT\r\n        self.if2_lut_buffer[:] = float(if2_filter.stop_floor) * -1.0 \r\n        \r\n        if if2_filter.model_type == 0: # Symmetric\r\n             fill_symmetric_filter_lut(\r\n                 self.if2_lut_buffer, \r\n                 if2_filter.center_hz, if2_filter.bw_hz,\r\n                 if2_filter.passband_il, if2_filter.rolloff,\r\n                 if2_filter.stop_floor,\r\n                 self.grid_step\r\n             )\r\n        elif if2_filter.model_type == 1: # S2P\r\n             # Check if prototype data exists\r\n             if len(self.cfg.if2_proto_norm_x) == 0:\r\n                 # Fallback if S2P enabled but no file loaded\r\n                 fill_symmetric_filter_lut(self.if2_lut_buffer, if2_filter.center_hz, if2_filter.bw_hz, \r\n                                           1.0, 40.0, if2_filter.stop_floor, self.grid_step)\r\n             else:\r\n                 fill_scaled_s2p_lut(\r\n                     self.if2_lut_buffer,\r\n                     if2_filter.center_hz, if2_filter.bw_hz,\r\n                     self.cfg.if2_proto_norm_x, self.cfg.if2_proto_val_y,\r\n                     if2_filter.stop_floor, self.grid_step\r\n                 )\r\n\r\n        # 2. Iterate Tiles\r\n        for tile in self.cfg.tiles:\r\n            best_tile_margin = -999.0\r\n            \r\n            # Try Sum-Sum (Non-Inverting)\r\n            m_sum = self._eval_chain_fast(tile, if2_filter, high_side=False, search_mode=search_mode)\r\n            if m_sum > best_tile_margin: best_tile_margin = m_sum\r\n            \r\n            # Try Diff-Diff (Non-Inverting)\r\n            m_diff = self._eval_chain_fast(tile, if2_filter, high_side=True, search_mode=search_mode)\r\n            if m_diff > best_tile_margin: best_tile_margin = m_diff\r\n            \r\n            if best_tile_margin == -999.0:\r\n                return -999.0, {} # No valid LO solution\r\n                \r\n            if best_tile_margin < worst_margin:\r\n                worst_margin = best_tile_margin\r\n                \r\n            # Early Exit in Search Mode\r\n            if search_mode and worst_margin < self.opt_cutoff:\r\n                return worst_margin, {}\r\n\r\n        return worst_margin, {}\r\n\r\n    def get_all_valid_candidates(self, tile: Tile, if2_filter: FilterModel, min_margin_db=0.0):\r\n        \"\"\" Used for final policy generation (Full Physics) \"\"\"\r\n        results = []\r\n        \r\n        # Re-fill IF2 LUT (Safety)\r\n        self.if2_lut_buffer[:] = float(if2_filter.stop_floor) * -1.0\r\n        if if2_filter.model_type == 0:\r\n             fill_symmetric_filter_lut(self.if2_lut_buffer, if2_filter.center_hz, if2_filter.bw_hz,\r\n                                       if2_filter.passband_il, if2_filter.rolloff, if2_filter.stop_floor, self.grid_step)\r\n        else:\r\n             fill_scaled_s2p_lut(self.if2_lut_buffer, if2_filter.center_hz, if2_filter.bw_hz,\r\n                                 self.cfg.if2_proto_norm_x, self.cfg.if2_proto_val_y,\r\n                                 if2_filter.stop_floor, self.grid_step)\r\n\r\n        # Run detailed eval (search_mode=False)\r\n        res_sum = self._eval_chain_detailed(tile, if2_filter, high_side=False)\r\n        if res_sum and res_sum[0] >= min_margin_db - 20.0:\r\n            results.append(res_sum)\r\n            \r\n        res_diff = self._eval_chain_detailed(tile, if2_filter, high_side=True)\r\n        if res_diff and res_diff[0] >= min_margin_db - 20.0:\r\n            results.append(res_diff)\r\n            \r\n        results.sort(key=lambda x: x[0], reverse=True)\r\n        return results\r\n\r\n    def _eval_chain_fast(self, tile, if2_filter, high_side, search_mode=True):\r\n        \"\"\" Returns margin (float) or -999 if invalid. \"\"\"\r\n        if high_side: # Diff: LO > Signal\r\n            lo1_freq = if2_filter.center_hz + tile.if1_center_hz\r\n            lo2_freq = tile.rf_center_hz + if2_filter.center_hz\r\n        else: # Sum: Signal + LO\r\n            lo1_freq = if2_filter.center_hz - tile.if1_center_hz\r\n            lo2_freq = tile.rf_center_hz - if2_filter.center_hz\r\n            \r\n        # 1. LO Validity Checks\r\n        valid1, _, _ = self.hw.get_valid_lo_config(self.hw.lo1_def, lo1_freq, self.hw.mixer1.drive_req)\r\n        if not valid1: return -999.0\r\n        \r\n        valid2, _, _ = self.hw.get_valid_lo_config(self.hw.lo2_def, lo2_freq, self.hw.mixer2.drive_req)\r\n        if not valid2: return -999.0\r\n        \r\n        # 2. Prepare Spectra\r\n        lo1_spec = self._get_lo_spectrum(self.hw.lo1_def, lo1_freq)\r\n        lo2_spec = self._get_lo_spectrum(self.hw.lo2_def, lo2_freq)\r\n        \r\n        # 3. Calculate Stage 1 Intermediates (SPARSE PRE-COMPUTE)\r\n        # Note: lo1_freq and tile.if1_center_hz determine the spurs.\r\n        # This isolates Stage 1 physics from LO2 loop.\r\n        stage1_spurs = compute_stage1_intermediates(\r\n            lo1_spec, lo1_freq, tile.if1_center_hz,\r\n            self.hw.mixer1.spur_table_np, not high_side,\r\n            self.if2_lut_buffer, self.grid_step, self.noise_floor,\r\n            search_mode\r\n        )\r\n        \r\n        # 4. Calculate Stage 2 (Mixing Intermediates + Desired with LO2)\r\n        f_if2_desired = if2_filter.center_hz\r\n        \r\n        margin = compute_stage2_from_intermediates(\r\n            stage1_spurs,\r\n            lo2_spec, lo2_freq, tile.rf_center_hz,\r\n            self.hw.mixer2.spur_table_np, not high_side,\r\n            f_if2_desired,\r\n            self.rf_lut, self.mask_lut,\r\n            self.grid_step, self.guard_db, self.noise_floor,\r\n            search_mode\r\n        )\r\n        \r\n        return margin\r\n\r\n    def _eval_chain_detailed(self, tile, if2_filter, high_side):\r\n        \"\"\" Returns full object tuple for policy storage. Always runs full physics. \"\"\"\r\n        margin = self._eval_chain_fast(tile, if2_filter, high_side, search_mode=False)\r\n        if margin == -999.0: return None\r\n        \r\n        if high_side:\r\n            lo1_freq = if2_filter.center_hz + tile.if1_center_hz\r\n            lo2_freq = tile.rf_center_hz + if2_filter.center_hz\r\n        else:\r\n            lo1_freq = if2_filter.center_hz - tile.if1_center_hz\r\n            lo2_freq = tile.rf_center_hz - if2_filter.center_hz\r\n            \r\n        valid1, pad1, p1 = self.hw.get_valid_lo_config(self.hw.lo1_def, lo1_freq, self.hw.mixer1.drive_req)\r\n        valid2, pad2, p2 = self.hw.get_valid_lo_config(self.hw.lo2_def, lo2_freq, self.hw.mixer2.drive_req)\r\n        \r\n        lo1_obj = LO_Candidate(lo1_freq, \"frac\", \"high\" if high_side else \"low\", p1, pad1, np.array([]))\r\n        lo2_obj = LO_Candidate(lo2_freq, \"frac\", \"high\" if high_side else \"low\", p2, pad2, np.array([]))\r\n        \r\n        return (margin, lo1_obj, lo2_obj)",
      "encoding": "utf-8",
      "encoding_error": false
    },
    {
      "type": "file",
      "name": "buc_kernels.py",
      "path": "buc_kernels.py",
      "size": 10074,
      "content_truncated": false,
      "contents": "import numpy as np\r\nfrom numba import jit\r\n\r\n# --- LUT Builders ---\r\n\r\ndef build_dense_lut(x_pts, y_pts, grid_max_hz, grid_step_hz, default_val):\r\n    \"\"\" Converts X/Y points into a dense array indexable by int(f / step). \"\"\"\r\n    n_bins = int(grid_max_hz / grid_step_hz) + 1\r\n    lut = np.full(n_bins, default_val, dtype=np.float32)\r\n    \r\n    if len(x_pts) == 0:\r\n        return lut\r\n\r\n    grid_freqs = np.linspace(0, grid_max_hz, n_bins)\r\n    interpolated = np.interp(grid_freqs, x_pts, y_pts)\r\n    lut[:] = interpolated\r\n    return lut\r\n\r\n# --- JIT Kernels ---\r\n\r\n@jit(nopython=True, fastmath=True)\r\ndef get_lut_val(f_hz, lut, step_hz):\r\n    \"\"\" O(1) Lookup \"\"\"\r\n    idx = int(f_hz / step_hz)\r\n    if idx < 0: return lut[0]\r\n    if idx >= len(lut): return lut[-1]\r\n    return lut[idx]\r\n\r\n@jit(nopython=True, fastmath=True)\r\ndef fill_symmetric_filter_lut(lut, center_hz, bw_hz, il_db, rolloff, stop_floor, step_hz):\r\n    \"\"\" Analytic fill for Symmetric Powerlaw IF2 filter. \"\"\"\r\n    n_bins = len(lut)\r\n    hbw = bw_hz / 2.0\r\n    \r\n    # Optimization bounds\r\n    start_f = center_hz - bw_hz * 5\r\n    stop_f = center_hz + bw_hz * 5\r\n    idx_start = max(0, int(start_f / step_hz))\r\n    idx_stop = min(n_bins, int(stop_f / step_hz))\r\n    \r\n    for i in range(idx_start, idx_stop):\r\n        f = i * step_hz\r\n        delta = abs(f - center_hz)\r\n        \r\n        if delta <= hbw:\r\n            lut[i] = il_db\r\n        else:\r\n            ratio = delta / hbw\r\n            atten = il_db + rolloff * np.log10(ratio)\r\n            if atten > -stop_floor: \r\n                lut[i] = -stop_floor\r\n            else:\r\n                lut[i] = atten\r\n\r\n@jit(nopython=True, fastmath=True)\r\ndef fill_scaled_s2p_lut(lut, center_hz, bw_hz, proto_x, proto_y, stop_floor, step_hz):\r\n    \"\"\" \r\n    Fills LUT by interpolating a normalized prototype.\r\n    \"\"\"\r\n    n_bins = len(lut)\r\n    \r\n    # Map Grid -> Normalized Domain -> Interp -> LUT\r\n    # Optimization bounds: map prototype X range to real freq\r\n    min_x = proto_x[0]\r\n    max_x = proto_x[-1]\r\n    \r\n    min_freq = min_x * bw_hz + center_hz\r\n    max_freq = max_x * bw_hz + center_hz\r\n    \r\n    idx_start = max(0, int(min_freq / step_hz))\r\n    idx_stop = min(n_bins, int(max_freq / step_hz))\r\n    \r\n    for i in range(idx_start, idx_stop):\r\n        f_grid = i * step_hz\r\n        x_req = (f_grid - center_hz) / bw_hz\r\n        \r\n        # Linear Interp on Prototype\r\n        val = np.interp(x_req, proto_x, proto_y)\r\n        \r\n        if val > -stop_floor:\r\n             lut[i] = -stop_floor\r\n        else:\r\n             lut[i] = val\r\n\r\n# --- CORE SPUR PHYSICS (SPLIT KERNELS) ---\r\n\r\n@jit(nopython=True, fastmath=True)\r\ndef compute_stage1_intermediates(\r\n    lo1_comps,          # [[freq, dBc], ...]\r\n    lo1_freq,           # Fundamental LO\r\n    if1_freq,\r\n    mxr1_table,         # [[m, n, rej], ...]\r\n    if2_side_high,      # bool: True if Sum, False if Diff\r\n    if2_lut,\r\n    grid_step,\r\n    noise_floor_dbc,\r\n    search_mode         # bool: if True, restrict orders\r\n):\r\n    \"\"\"\r\n    Calculates all significant spur tones entering Stage 2.\r\n    Returns a simplified array: [[freq_hz, level_dBm_equiv], ...]\r\n    \"\"\"\r\n    # Heuristic sizing: max 50 spurs to avoid dynamic allocation issues\r\n    results = np.zeros((100, 2), dtype=np.float64)\r\n    count = 0\r\n    \r\n    if if2_side_high:\r\n        f_if2_desired = lo1_freq + if1_freq\r\n    else:\r\n        f_if2_desired = abs(lo1_freq - if1_freq)\r\n\r\n    n_lo1 = lo1_comps.shape[0]\r\n    n_mx1 = mxr1_table.shape[0]\r\n    \r\n    # Search mode constraints\r\n    max_k = 3 if search_mode else 99\r\n    max_ord = 3 if search_mode else 99\r\n\r\n    for k1 in range(n_lo1):\r\n        # In search mode, skip high harmonics\r\n        if search_mode and k1 > max_k: break\r\n        \r\n        f_lo1_c = lo1_comps[k1, 0]\r\n        p_lo1_c = lo1_comps[k1, 1]\r\n        \r\n        for i1 in range(n_mx1):\r\n            m1 = int(mxr1_table[i1, 0])\r\n            n1 = int(mxr1_table[i1, 1])\r\n            \r\n            if search_mode and (m1 > max_ord or n1 > max_ord): continue\r\n            \r\n            rej1 = mxr1_table[i1, 2]\r\n            \r\n            for s_lo1 in (-1, 1):\r\n                for s_if1 in (-1, 1):\r\n                    # Spur Frequency at IF2 Output\r\n                    f_spur_if2 = abs(s_lo1 * m1 * f_lo1_c + s_if1 * n1 * if1_freq)\r\n                    \r\n                    # Strict Integer Check for Desired Path to avoid Float issues\r\n                    is_desired = (k1==0 and m1==1 and n1==1)\r\n                    if is_desired:\r\n                        # Verify signs match architecture (Sum vs Diff)\r\n                        # Sum: +LO +IF (or -LO -IF -> abs)\r\n                        # Diff: +LO -IF (or -LO +IF -> abs)\r\n                        # We skip the *Desired Signal* here because it is handled \r\n                        # as a separate \"Main Carrier\" in Stage 2.\r\n                        # However, we MUST ensure we are skipping the specific sign combo \r\n                        # corresponding to the desired path.\r\n                        # For simplicity in this sparse kernel:\r\n                        if abs(f_spur_if2 - f_if2_desired) < 1.0:\r\n                            continue\r\n\r\n                    # Level at Mixer 1 Output\r\n                    lvl_s1 = p_lo1_c + rej1 \r\n                    \r\n                    # Apply IF2 Filter\r\n                    atten_if2 = get_lut_val(f_spur_if2, if2_lut, grid_step)\r\n                    lvl_input_to_m2 = lvl_s1 - atten_if2\r\n                    \r\n                    # Prune weak spurs\r\n                    if lvl_input_to_m2 < noise_floor_dbc: continue\r\n                    \r\n                    # Store\r\n                    if count < 100:\r\n                        results[count, 0] = f_spur_if2\r\n                        results[count, 1] = lvl_input_to_m2\r\n                        count += 1\r\n                        \r\n    return results[:count]\r\n\r\n@jit(nopython=True, fastmath=True)\r\ndef compute_stage2_from_intermediates(\r\n    stage1_spurs,       # [[freq, lvl], ...] from previous kernel\r\n    lo2_comps,          # [[freq, dBc], ...]\r\n    lo2_freq,           # Fund LO2\r\n    rf_freq,            # Desired RF\r\n    mxr2_table,         # [[m, n, rej], ...]\r\n    rf_side_high,       # bool: True if Sum, False if Diff\r\n    f_if2_desired,      # The main IF2 signal frequency\r\n    rf_lut,\r\n    mask_lut,\r\n    grid_step,\r\n    guard_db,\r\n    noise_floor_dbc,\r\n    search_mode         # bool\r\n):\r\n    \"\"\"\r\n    Mixes (Stage1_Spurs + Desired_IF2) with LO2 -> RF.\r\n    Checks against masks.\r\n    \"\"\"\r\n    min_margin = 999.0\r\n    \r\n    n_lo2 = lo2_comps.shape[0]\r\n    n_mx2 = mxr2_table.shape[0]\r\n    n_s1 = stage1_spurs.shape[0]\r\n    \r\n    max_k = 3 if search_mode else 99\r\n    max_ord = 3 if search_mode else 99\r\n\r\n    # 1. Process Desired IF2 Signal -> Stage 2 Spurs\r\n    # This is the standard \"Mixer 2 Spur Table\" analysis\r\n    for k2 in range(n_lo2):\r\n        if search_mode and k2 > max_k: break\r\n        \r\n        f_lo2_c = lo2_comps[k2, 0]\r\n        p_lo2_c = lo2_comps[k2, 1]\r\n        \r\n        for i2 in range(n_mx2):\r\n            m2 = int(mxr2_table[i2, 0])\r\n            n2 = int(mxr2_table[i2, 1])\r\n            \r\n            if search_mode and (m2 > max_ord or n2 > max_ord): continue\r\n            \r\n            rej2 = mxr2_table[i2, 2]\r\n            \r\n            for s_lo2 in (-1, 1):\r\n                for s_if2 in (-1, 1):\r\n                    f_spur_rf = abs(s_lo2 * m2 * f_lo2_c + s_if2 * n2 * f_if2_desired)\r\n                    \r\n                    # Skip Desired RF Output\r\n                    if k2==0 and m2==1 and n2==1 and abs(f_spur_rf - rf_freq) < 1.0:\r\n                        continue\r\n                        \r\n                    lvl = p_lo2_c + rej2 \r\n                    \r\n                    atten_rf = get_lut_val(f_spur_rf, rf_lut, grid_step)\r\n                    final_lvl = lvl - atten_rf\r\n                    \r\n                    if final_lvl < noise_floor_dbc: continue\r\n                    \r\n                    limit = get_lut_val(f_spur_rf, mask_lut, grid_step)\r\n                    margin = limit - final_lvl - guard_db\r\n                    \r\n                    if margin < min_margin:\r\n                        min_margin = margin\r\n\r\n    # 2. Process Stage 1 Spurs (Leakage) -> Stage 2\r\n    # Treat these as \"Fundamental\" inputs (n2=1) usually\r\n    for i_s1 in range(n_s1):\r\n        f_input = stage1_spurs[i_s1, 0]\r\n        l_input = stage1_spurs[i_s1, 1]\r\n        \r\n        for k2 in range(n_lo2):\r\n            if search_mode and k2 > max_k: break\r\n            \r\n            f_lo2_c = lo2_comps[k2, 0]\r\n            p_lo2_c = lo2_comps[k2, 1]\r\n            \r\n            # Optimization: Only mix spurious inputs with n2=1 (Linear translation)\r\n            # Higher order intermods of spurs are usually < -120dBc\r\n            for i2 in range(n_mx2):\r\n                n2 = int(mxr2_table[i2, 1])\r\n                if n2 != 1: continue \r\n                \r\n                m2 = int(mxr2_table[i2, 0])\r\n                # if search_mode and m2 > max_ord: continue # n2 is already 1\r\n                \r\n                rej2 = mxr2_table[i2, 2]\r\n                \r\n                for s_lo2 in (-1, 1):\r\n                    for s_if2 in (-1, 1):\r\n                        # Mixing equation\r\n                        f_final_rf = abs(s_lo2 * m2 * f_lo2_c + s_if2 * n2 * f_input)\r\n                        \r\n                        # Level = Input + LO_Harm_Drop + Mixer_Loss\r\n                        lvl_rf = l_input + p_lo2_c + rej2\r\n                        \r\n                        atten_rf = get_lut_val(f_final_rf, rf_lut, grid_step)\r\n                        final_lvl = lvl_rf - atten_rf\r\n                        \r\n                        if final_lvl < noise_floor_dbc: continue\r\n                        \r\n                        limit = get_lut_val(f_final_rf, mask_lut, grid_step)\r\n                        margin = limit - final_lvl - guard_db\r\n                        \r\n                        if margin < min_margin:\r\n                            min_margin = margin\r\n\r\n    return min_margin",
      "encoding": "utf-8",
      "encoding_error": false
    },
    {
      "type": "file",
      "name": "buc_models.py",
      "path": "buc_models.py",
      "size": 6881,
      "content_truncated": false,
      "contents": "import numpy as np\r\nfrom buc_structures import MixerModel, SynthesizerModel\r\n\r\nclass HardwareStack:\r\n    def __init__(self, cfg, stack_def):\r\n        self.name = stack_def['name']\r\n        self.mixer1 = self._find_mixer(cfg, stack_def['mixer1'])\r\n        self.mixer2 = self._find_mixer(cfg, stack_def['mixer2'])\r\n        self.lo1_def = self._find_lo(cfg, stack_def['lo1'], \"lo1\")\r\n        self.lo2_def = self._find_lo(cfg, stack_def['lo2'], \"lo2\")\r\n    \r\n    def _find_mixer(self, cfg, name):\r\n        for m in cfg.yaml_data['mixers']:\r\n            if m['name'] == name:\r\n                return MixerModel(\r\n                    name=m['name'],\r\n                    lo_range=tuple(m['lo_range_hz']),\r\n                    drive_req=(m['required_lo_drive_dbm']['min'], m['required_lo_drive_dbm']['max']),\r\n                    isolation=m['isolation'],\r\n                    spur_table_raw=[(x[0], x[1], x[2]) for x in m['spur_list']]\r\n                )\r\n        raise ValueError(f\"Mixer {name} not found\")\r\n\r\n    def _find_lo(self, cfg, name, role):\r\n        for l in cfg.yaml_data['los']:\r\n            if l['name'] == name:\r\n                # Distribution & Pads\r\n                dist_cfg = l.get('distribution', {})\r\n                dist_loss = dist_cfg.get('path_losses_db', {}).get(role, 3.0)\r\n                pads = dist_cfg.get('pad_options_db', [0, 3, 6])\r\n\r\n                # Power Model\r\n                p_freqs = np.array([1e6, 40e9])\r\n                p_vals = np.array([l.get('output_power_dbm', 0)] * 2)\r\n                \r\n                if 'output_power_model' in l and 'table' in l['output_power_model']:\r\n                    tbl = l['output_power_model']['table']\r\n                    p_freqs = np.array(tbl['freq_hz'])\r\n                    p_vals = np.array(tbl['p_out_dbm'])\r\n\r\n                # Spectral Defs\r\n                modes = l.get('modes', [])\r\n                harmonics = []\r\n                pfd_spurs = []\r\n                pfd_hz = 100e6\r\n                \r\n                frac_en = False\r\n                frac_lvl = -60\r\n                frac_slope = 10\r\n                \r\n                if modes:\r\n                    m = modes[0] # Default to first mode\r\n                    harmonics = m.get('harmonics', [])\r\n                    \r\n                    # PFD Spurs\r\n                    pfd_cfg = m.get('pfd_spurs_at_output', {})\r\n                    if 'families' in pfd_cfg:\r\n                        for fam in pfd_cfg['families']:\r\n                             if 'components' in fam:\r\n                                 pfd_spurs.extend(fam['components'])\r\n                    \r\n                    if 'pfd_hz_range' in m:\r\n                        pfd_hz = (m['pfd_hz_range'][0] + m['pfd_hz_range'][1]) / 2\r\n                    \r\n                    # Fractional Boundary\r\n                    fb = m.get('frac_boundary_spurs', {})\r\n                    frac_en = fb.get('enabled', False)\r\n                    frac_lvl = fb.get('amplitude_at_eps0p5_rel_dBc', -58)\r\n                    frac_slope = fb.get('rolloff_slope_db_per_dec', 10)\r\n\r\n                return SynthesizerModel(\r\n                    name=l['name'],\r\n                    freq_range=tuple(l['freq_range_hz']),\r\n                    step_hz=l.get('step_hz', 100e3),\r\n                    power_freqs=p_freqs,\r\n                    power_dbm=p_vals,\r\n                    dist_loss_db=dist_loss,\r\n                    pad_options=pads,\r\n                    harmonics=harmonics,\r\n                    pfd_freq_hz=pfd_hz,\r\n                    pfd_spurs=pfd_spurs,\r\n                    frac_boundary_enabled=frac_en,\r\n                    frac_boundary_lvl=frac_lvl,\r\n                    frac_boundary_slope=frac_slope\r\n                )\r\n        raise ValueError(f\"LO {name} not found\")\r\n\r\n    def get_valid_lo_config(self, lo_model: SynthesizerModel, target_freq, mixer_drive_req):\r\n        \"\"\"\r\n        Checks range, and pads. Returns (is_valid, pad_used, delivered_power).\r\n        \"\"\"\r\n        if target_freq < lo_model.freq_range[0] or target_freq > lo_model.freq_range[1]:\r\n            return False, 0, 0\r\n\r\n        p_source = np.interp(target_freq, lo_model.power_freqs, lo_model.power_dbm)\r\n        \r\n        valid_pads = []\r\n        for pad in lo_model.pad_options:\r\n            p_del = p_source - lo_model.dist_loss_db - pad\r\n            if mixer_drive_req[0] <= p_del <= mixer_drive_req[1]:\r\n                valid_pads.append((pad, p_del))\r\n        \r\n        if not valid_pads:\r\n            return False, 0, 0\r\n        \r\n        # Prefer lowest power that meets requirement to save energy/compression\r\n        valid_pads.sort(key=lambda x: x[1]) \r\n        best = valid_pads[0]\r\n        return True, best[0], best[1]\r\n\r\n    def generate_lo_spectrum(self, lo_model: SynthesizerModel, f_center):\r\n        \"\"\"\r\n        Generates 2D numpy array [[freq, rel_dBc], ...].\r\n        Includes Main Tone, Harmonics, PFD spurs, and Boundary Spurs.\r\n        \"\"\"\r\n        comps = []\r\n        # 1. Main Tone\r\n        comps.append([f_center, 0.0])\r\n        \r\n        # 2. Harmonics\r\n        for h in lo_model.harmonics:\r\n            comps.append([f_center * h['k'], h['rel_dBc']])\r\n            \r\n        # 3. PFD Spurs\r\n        for p in lo_model.pfd_spurs:\r\n            offset = p['k'] * lo_model.pfd_freq_hz\r\n            lvl = p.get('base_rel_dBc', -60)\r\n            comps.append([f_center + offset, lvl])\r\n            comps.append([f_center - offset, lvl])\r\n\r\n        # 4. Fractional Boundary Spurs\r\n        if lo_model.frac_boundary_enabled and lo_model.pfd_freq_hz > 0:\r\n            # Calculate N and fraction\r\n            N_float = f_center / lo_model.pfd_freq_hz\r\n            N_int = round(N_float)\r\n            \r\n            # Distance to integer boundary (epsilon)\r\n            epsilon = abs(N_float - N_int)\r\n            \r\n            # If exactly integer, no boundary spur (or handling integer mode)\r\n            if epsilon > 1e-6:\r\n                # Boundary spur frequency is at distance (epsilon * f_pfd) from carrier\r\n                # which maps physically to: f_spur = f_center +/- (epsilon * f_pfd)\r\n                # But wait, boundary spurs usually appear at N_int * f_pfd\r\n                # f_boundary = N_int * f_pfd\r\n                f_boundary = N_int * lo_model.pfd_freq_hz\r\n                \r\n                # Amplitude model: L = L_0.5 + Slope * log10(0.5 / epsilon)\r\n                # Smaller epsilon (closer to boundary) -> Higher spur\r\n                if epsilon > 0.5: epsilon = 1.0 - epsilon # normalize 0..0.5\r\n                \r\n                delta_dec = np.log10(0.5 / epsilon)\r\n                lvl = lo_model.frac_boundary_lvl + lo_model.frac_boundary_slope * delta_dec\r\n                \r\n                # Cap at 0 dBc just in case\r\n                lvl = min(0, lvl)\r\n                comps.append([f_boundary, lvl])\r\n\r\n        return np.array(comps, dtype=np.float64)",
      "encoding": "utf-8",
      "encoding_error": false
    },
    {
      "type": "file",
      "name": "buc_structures.py",
      "path": "buc_structures.py",
      "size": 6799,
      "content_truncated": false,
      "contents": "import yaml\r\nimport numpy as np\r\nimport os\r\nfrom dataclasses import dataclass, field\r\nfrom typing import List, Dict, Tuple, Optional\r\n\r\n@dataclass\r\nclass Tile:\r\n    id: int\r\n    if1_center_hz: float\r\n    bw_hz: float\r\n    rf_center_hz: float\r\n\r\n@dataclass\r\nclass MixerModel:\r\n    name: str\r\n    lo_range: Tuple[float, float]\r\n    drive_req: Tuple[float, float]\r\n    isolation: Dict[str, float]\r\n    spur_table_raw: List[Tuple[int, int, float]]\r\n    # Flattened numpy array for JIT: [[m, n, rej], ...]\r\n    spur_table_np: np.ndarray = field(init=False)\r\n\r\n    def __post_init__(self):\r\n        self.spur_table_np = np.array(self.spur_table_raw, dtype=np.float64)\r\n\r\n@dataclass\r\nclass SynthesizerModel:\r\n    name: str\r\n    freq_range: Tuple[float, float]\r\n    step_hz: float\r\n    # Power Model\r\n    power_freqs: np.ndarray\r\n    power_dbm: np.ndarray\r\n    # Distribution\r\n    dist_loss_db: float\r\n    pad_options: List[float]\r\n    # Spectral Purity\r\n    harmonics: List[Dict] \r\n    pfd_freq_hz: float\r\n    pfd_spurs: List[Dict]\r\n    # Fractional Boundary Spurs\r\n    frac_boundary_enabled: bool\r\n    frac_boundary_lvl: float  # Level at epsilon=0.5\r\n    frac_boundary_slope: float\r\n\r\n@dataclass\r\nclass LO_Candidate:\r\n    freq_hz: float\r\n    mode: str \r\n    side: str \r\n    delivered_power_dbm: float\r\n    pad_db: float\r\n    # 2D Array [[freq_hz, rel_dBc], ...] - Contains Main + Harmonics + Spurs\r\n    spectrum: np.ndarray \r\n\r\n@dataclass\r\nclass FilterModel:\r\n    center_hz: float = 0.0\r\n    bw_hz: float = 0.0\r\n    model_type: int = 0  # 0=Symmetric, 1=S2P\r\n    passband_il: float = 1.0\r\n    rolloff: float = 40.0 \r\n    stop_floor: float = -80.0\r\n    # Pointers to global prototype arrays (not stored per instance to save RAM)\r\n    proto_idx: int = -1 \r\n\r\n@dataclass\r\nclass GlobalConfig:\r\n    yaml_data: dict\r\n    tiles: List[Tile] = field(default_factory=list)\r\n    \r\n    # Global Settings\r\n    grid_max_freq_hz: float = 40e9\r\n    grid_step_hz: float = 1e6\r\n    opt_cutoff_db: float = -20.0\r\n    noise_floor_dbc: float = -100.0\r\n    \r\n    # Pre-loaded physics Arrays\r\n    rf_filter_raw_freqs: np.ndarray = field(default_factory=lambda: np.array([]))\r\n    rf_filter_raw_atten: np.ndarray = field(default_factory=lambda: np.array([]))\r\n    \r\n    # Normalized IF2 Prototype (X axis = normalized frequency diff, Y = dB)\r\n    if2_proto_norm_x: np.ndarray = field(default_factory=lambda: np.array([]))\r\n    if2_proto_val_y: np.ndarray = field(default_factory=lambda: np.array([]))\r\n    \r\n    @staticmethod\r\n    def load(path: str):\r\n        with open(path, 'r') as f:\r\n            data = yaml.safe_load(f)\r\n        \r\n        cfg = GlobalConfig(yaml_data=data)\r\n        cfg._generate_tiles()\r\n        \r\n        # Load Grid Config\r\n        grid_cfg = data.get('rbw_binning', {})\r\n        grid_glob = data.get('grids', {})\r\n        cfg.grid_step_hz = float(grid_cfg.get('lut_step_hz', 1e6)) \r\n        cfg.grid_max_freq_hz = float(grid_glob.get('grid_max_freq_hz', 45e9))\r\n        \r\n        # Load Settings\r\n        run_set = data.get('runtime_settings', {})\r\n        cfg.opt_cutoff_db = float(run_set.get('optimization_cutoff_db', -20.0))\r\n        cfg.noise_floor_dbc = float(run_set.get('noise_floor_cutoff_dbc', -100.0))\r\n        \r\n        hw_choices = data.get('hardware_choices', {}).get('stacks', [])\r\n        rf_file = hw_choices[0].get('rf_bpf_file', None) if hw_choices else None\r\n        cfg._build_filter_profile(rf_file, is_rf=True)\r\n        \r\n        if2_opts = data.get('if2_model', {}).get('scaled_s2p', {})\r\n        if if2_opts.get('enabled', False):\r\n            cfg._build_filter_profile(if2_opts.get('prototype_s2p_file'), is_rf=False)\r\n            \r\n        return cfg\r\n\r\n    def _generate_tiles(self):\r\n        g = self.yaml_data['grids']\r\n        b = self.yaml_data['bands']\r\n        if1_min, if1_max = float(b['if1_hz']['min']), float(b['if1_hz']['max'])\r\n        rf_min, rf_max = float(b['rf_hz']['min']), float(b['rf_hz']['max'])\r\n        \r\n        if1s = np.arange(if1_min, if1_max + 1e5, g['if1_center_step_hz'])\r\n        rfs = np.arange(rf_min, rf_max + 1e5, g['rf_center_step_hz'])\r\n        bws = g['bw_grid_hz']\r\n        \r\n        tid = 0\r\n        for bw in bws:\r\n            for if1 in if1s:\r\n                if (if1 - bw/2) < if1_min or (if1 + bw/2) > if1_max:\r\n                    continue\r\n                for rf in rfs:\r\n                    self.tiles.append(Tile(tid, if1, bw, rf))\r\n                    tid += 1\r\n\r\n    def _build_filter_profile(self, file_path, is_rf=True):\r\n        freqs, atten = np.array([]), np.array([])\r\n        loaded = False\r\n        \r\n        if file_path and os.path.exists(file_path):\r\n            try:\r\n                # Basic S2P/CSV parser: Freq(Hz or GHz), S21(dB)\r\n                data = np.loadtxt(file_path, comments=['!', '#'], delimiter=None)\r\n                if data.shape[0] > 1 and data.shape[1] >= 2:\r\n                    freqs = data[:, 0]\r\n                    # Robust GHz detection: if max freq is small, assume GHz\r\n                    if np.max(freqs) < 200.0: \r\n                        freqs *= 1e9 \r\n                    vals = data[:, 1]\r\n                    # Ensure attenuation is positive dB (Loss)\r\n                    atten = -vals if np.mean(vals) < 0 else vals\r\n                    loaded = True\r\n            except Exception as e: \r\n                print(f\"Warning: Failed to load filter {file_path}: {e}\")\r\n\r\n        # Fallback for RF\r\n        if not loaded and is_rf:\r\n            b = self.yaml_data['bands']['rf_hz']\r\n            freqs = np.array([0, b['min']-1e6, b['min'], b['max'], b['max']+1e6, 100e9])\r\n            atten = np.array([80, 80, 1.0, 1.0, 80, 80])\r\n            \r\n        if is_rf: \r\n            self.rf_filter_raw_freqs, self.rf_filter_raw_atten = freqs, atten\r\n        elif loaded:\r\n            # Normalize IF2 Prototype\r\n            # 1. Find Center (Minimum Loss)\r\n            min_idx = np.argmin(atten)\r\n            f_center = freqs[min_idx]\r\n            min_loss = atten[min_idx]\r\n            \r\n            # 2. Find 3dB BW\r\n            target_loss = min_loss + 3.0\r\n            # Simple search\r\n            f_lower = f_center\r\n            for i in range(min_idx, -1, -1):\r\n                if atten[i] >= target_loss:\r\n                    f_lower = freqs[i]\r\n                    break\r\n            f_upper = f_center\r\n            for i in range(min_idx, len(freqs)):\r\n                if atten[i] >= target_loss:\r\n                    f_upper = freqs[i]\r\n                    break\r\n            \r\n            bw_meas = f_upper - f_lower\r\n            if bw_meas <= 0: bw_meas = 1.0 # Safety\r\n            \r\n            # 3. Normalize\r\n            # X = (f - f_c) / BW\r\n            # Y = atten\r\n            self.if2_proto_norm_x = (freqs - f_center) / bw_meas\r\n            self.if2_proto_val_y = atten",
      "encoding": "utf-8",
      "encoding_error": false
    },
    {
      "type": "file",
      "name": "buc_visuals.py",
      "path": "buc_visuals.py",
      "size": 1411,
      "content_truncated": false,
      "contents": "import pandas as pd\r\nimport matplotlib.pyplot as plt\r\nimport numpy as np\r\n\r\ndef plot_margin_heatmap(df_policy, filename=\"heatmap_margin.png\"):\r\n    \"\"\"\r\n    Generates a 2D heatmap of Spur Margin vs IF1 and RF Center frequencies.\r\n    \"\"\"\r\n    if df_policy.empty:\r\n        print(\"No policy data to plot.\")\r\n        return\r\n\r\n    # Pivot Data\r\n    # X-axis: IF1 (MHz), Y-axis: RF (GHz), Value: Margin\r\n    pivot = df_policy.pivot_table(\r\n        index='rf_hz', \r\n        columns='if1_hz', \r\n        values='margin'\r\n    )\r\n    \r\n    # Convert index/cols for readability\r\n    pivot.index = pivot.index / 1e9\r\n    pivot.columns = pivot.columns / 1e6\r\n    \r\n    plt.figure(figsize=(12, 8))\r\n    \r\n    # Create Heatmap\r\n    # Vmin/Vmax clamp color scale to useful range (e.g., 0dB to 20dB)\r\n    plt.imshow(\r\n        pivot, \r\n        aspect='auto', \r\n        origin='lower', \r\n        cmap='RdYlGn', \r\n        vmin=0, \r\n        vmax=20,\r\n        extent=[pivot.columns.min(), pivot.columns.max(), pivot.index.min(), pivot.index.max()]\r\n    )\r\n    \r\n    cbar = plt.colorbar()\r\n    cbar.set_label('Spur Margin (dB)')\r\n    \r\n    plt.xlabel('IF1 Center Frequency (MHz)')\r\n    plt.ylabel('RF Center Frequency (GHz)')\r\n    plt.title('BUC Spur Margin Heatmap\\n(Green = Good, Red = Fail)')\r\n    plt.grid(False)\r\n    \r\n    plt.tight_layout()\r\n    plt.savefig(filename)\r\n    print(f\"Heatmap saved to {filename}\")\r\n    plt.close()",
      "encoding": "utf-8",
      "encoding_error": false
    },
    {
      "type": "file",
      "name": "config.yaml",
      "path": "config.yaml",
      "size": 2824,
      "content_truncated": false,
      "contents": "project:\r\n  name: \"KaBUC-SpurPlan\"\r\n  seed: 42\r\n  reference_10mhz_hz: 10000000\r\n\r\nbands:\r\n  if1_hz: {min: 950.0e+6, max: 2150.0e+6}\r\n  rf_hz:  {min: 27.5e+9, max: 31.0e+9}\r\n  required_bandwidths_hz: [400.0e+6]\r\n\r\ngrids:\r\n  if1_center_step_hz: 50.0e+6\r\n  rf_center_step_hz: 100.0e+6\r\n  bw_grid_hz: [400.0e+6]\r\n  snap_if1_rf_to_grid: true\r\n  grid_max_freq_hz: 45.0e+9\r\n\r\nmasks:\r\n  inband:\r\n    default_dbc: -60.0\r\n    table: []\r\n  outofband:\r\n    default_dbc: -50.0\r\n    table: []\r\n\r\nrbw_binning:\r\n  lut_step_hz: 2.0e+6\r\n\r\nhardware_choices:\r\n  stacks:\r\n    - name: \"Stack_Alpha\"\r\n      mixer1: \"MXR1_Gen\"\r\n      mixer2: \"MXR2_Gen\"\r\n      lo1: \"LMX2595_Sim\"\r\n      lo2: \"LMX2595_Sim\"\r\n      rf_bpf_file: \"rf_bpf_sim.csv\"\r\n\r\norders:\r\n  m1n1_max_abs: 5\r\n  m2n2_max_abs: 5\r\n  cross_stage_sum_max: 8\r\n\r\nconstraints:\r\n  guard_margin_db: 3.0\r\n  enforce_non_inverting_chain: true\r\n\r\ntarget_specs:\r\n  min_margin_db: 0.0\r\n\r\nruntime_settings:\r\n  optimization_cutoff_db: -20.0   # Early exit if margin is worse than this\r\n  noise_floor_cutoff_dbc: -100.0  # Don't track spurs below this relative level\r\n  s2p_normalization_method: \"3db_width\" # How to define '1.0' BW in S2P files\r\n\r\nmixers:\r\n  - name: \"MXR1_Gen\"\r\n    lo_range_hz: [100e6, 15e9]\r\n    required_lo_drive_dbm: {min: 0, max: 20}\r\n    isolation: {lo_to_rf_db: -30, if_to_rf_db: -50}\r\n    spur_list:\r\n      - [1, 2, -55]\r\n      - [2, 1, -50]\r\n      - [2, 2, -65]\r\n      - [3, 1, -60]\r\n      - [1, 3, -60]\r\n  \r\n  - name: \"MXR2_Gen\"\r\n    lo_range_hz: [100e6, 20e9]\r\n    required_lo_drive_dbm: {min: 0, max: 20}\r\n    isolation: {lo_to_rf_db: -30, if_to_rf_db: -50}\r\n    spur_list:\r\n      - [1, 2, -50]\r\n      - [2, 1, -45]\r\n      - [2, 2, -60]\r\n      - [3, 1, -55]\r\n\r\nlos:\r\n  - name: \"LMX2595_Sim\"\r\n    freq_range_hz: [100e6, 20e9]\r\n    step_hz: 1000\r\n    output_power_dbm: 5.0\r\n    distribution:\r\n      path_losses_db: {lo1: 3.0, lo2: 4.0}\r\n      pad_options_db: [0, 3, 6]\r\n    modes:\r\n      - name: \"fracN\"\r\n        pfd_hz_range: [100e6, 100e6]\r\n        harmonics: \r\n          - {k: 2, rel_dBc: -25}\r\n          - {k: 3, rel_dBc: -35}\r\n        pfd_spurs_at_output:\r\n           families:\r\n             - components: \r\n               - {k: 1, base_rel_dBc: -65}\r\n        frac_boundary_spurs:\r\n           enabled: true\r\n           amplitude_at_eps0p5_rel_dBc: -58\r\n           rolloff_slope_db_per_dec: 10\r\n\r\nif2_model:\r\n  type: \"symmetric_powerlaw\"  # Change to \"scaled_s2p_prototype\" to test S2P\r\n  passband_il_db: 1.5\r\n  stop_floor_db: -70.0\r\n  rolloff_db_per_dec: 40.0\r\n  min_bw_hz: 500.0e+6\r\n  max_bw_hz: 2000.0e+6\r\n  center_range_hz: [3000.0e+6, 8000.0e+6]\r\n  search:\r\n    coarse_center_step_hz: 200.0e+6\r\n    coarse_bw_step_hz: 200.0e+6\r\n    top_k_seeds_for_refinement: 2\r\n    max_refine_iters: 5\r\n  scaled_s2p:\r\n    enabled: false\r\n    prototype_s2p_file: \"if2_prototype.s2p\"",
      "encoding": "utf-8",
      "encoding_error": false
    },
    {
      "type": "file",
      "name": "main.py",
      "path": "main.py",
      "size": 7185,
      "content_truncated": false,
      "contents": "import time\nimport pandas as pd\nimport numpy as np\nfrom colorama import Fore, Style\nfrom multiprocessing import Pool, cpu_count\n\nfrom buc_structures import GlobalConfig, FilterModel\nfrom buc_models import HardwareStack\nfrom buc_engine import SpurEngine\nfrom buc_diagnostics import generate_spur_ledger\nfrom buc_visuals import plot_margin_heatmap\n\n# Global engine instance for workers\nworker_engine = None\n\ndef init_worker(config, stack_def):\n    global worker_engine\n    hw = HardwareStack(config, stack_def)\n    worker_engine = SpurEngine(config, hw)\n\ndef evaluate_wrapper(if2_model):\n    # Workers run in \"Search Mode\" (fast) by default\n    score, _ = worker_engine.evaluate_policy(if2_model, search_mode=True)\n    return (score, if2_model)\n\ndef local_refinement(engine, seed_if2, initial_score):\n    \"\"\" Performs coordinate descent around the seed. \"\"\"\n    current_if2 = seed_if2\n    current_score = initial_score\n    \n    # Coarse then Fine steps\n    steps = [50e6, 10e6, 2e6] \n    print(f\"{Fore.MAGENTA}--- Starting Local Refinement on Seed {seed_if2.center_hz/1e9:.2f}GHz ---{Style.RESET_ALL}\")\n    \n    for step in steps:\n        improved = True\n        while improved:\n            improved = False\n            neighbors = []\n            base_c = current_if2.center_hz\n            \n            # Try +/- Step in Frequency\n            for d in [-step, step]:\n                neighbors.append(FilterModel(\n                    base_c + d, current_if2.bw_hz, \n                    current_if2.model_type, current_if2.passband_il, \n                    current_if2.rolloff, current_if2.stop_floor\n                ))\n                \n            for n in neighbors:\n                # Use full physics (search_mode=False) for refinement accuracy?\n                # Trade-off: Speed vs Precision. \n                # Typically, use search_mode=True for first steps, False for final.\n                # Here we use True for speed, trusting it correlates with False.\n                s, _ = engine.evaluate_policy(n, search_mode=True)\n                \n                if s > current_score + 0.01:\n                    current_score = s\n                    current_if2 = n\n                    improved = True\n                    print(f\"  > Improved: {current_if2.center_hz/1e9:.3f}GHz -> {current_score:.2f} dB\")\n                    \n    # Final verification with full physics\n    final_score, _ = engine.evaluate_policy(current_if2, search_mode=False)\n    return current_if2, final_score\n\ndef build_policy_csv(engine, if2_filter, tiles):\n    rows = []\n    for t in tiles:\n        cands = engine.get_all_valid_candidates(t, if2_filter, min_margin_db=engine.opt_cutoff)\n        if not cands:\n            rows.append({\"tile_id\": t.id, \"margin\": -999, \"if1_hz\": t.if1_center_hz, \"rf_hz\": t.rf_center_hz})\n            continue\n        best = cands[0]\n        margin, lo1, lo2 = best\n        rows.append({\n            \"tile_id\": t.id,\n            \"if1_hz\": t.if1_center_hz,\n            \"rf_hz\": t.rf_center_hz,\n            \"lo1_hz\": lo1.freq_hz, \"lo1_pad\": lo1.pad_db,\n            \"lo2_hz\": lo2.freq_hz, \"lo2_pad\": lo2.pad_db,\n            \"margin\": margin,\n            \"if2_center\": if2_filter.center_hz\n        })\n    return pd.DataFrame(rows)\n\ndef main():\n    print(f\"{Fore.CYAN}=== Dual-Conversion BUC Spur Optimizer (Accelerated) ==={Style.RESET_ALL}\")\n    cfg = GlobalConfig.load(\"config.yaml\")\n    stacks = cfg.yaml_data['hardware_choices']['stacks']\n    \n    best_global_score = -999\n    best_global_setup = None \n    \n    num_workers = max(1, cpu_count() - 1)\n    TOP_K_SEEDS = cfg.yaml_data['if2_model']['search'].get('top_k_seeds_for_refinement', 3)\n    \n    for stack_def in stacks:\n        print(f\"\\nEvaluating Hardware Stack: {Fore.GREEN}{stack_def['name']}{Style.RESET_ALL}\")\n        if2_cfg = cfg.yaml_data['if2_model']\n        \n        # Determine Filter Type (0=Parametric, 1=S2P)\n        ftype = 1 if (if2_cfg.get('scaled_s2p', {}).get('enabled', False)) else 0\n        \n        centers = np.arange(if2_cfg['center_range_hz'][0], if2_cfg['center_range_hz'][1], if2_cfg['search']['coarse_center_step_hz'])\n        bws = np.arange(if2_cfg['min_bw_hz'], if2_cfg['max_bw_hz'], if2_cfg['search']['coarse_bw_step_hz'])\n        \n        tasks = []\n        for c in centers:\n            for bw in bws:\n                tasks.append(FilterModel(\n                    c, bw, ftype, \n                    if2_cfg['passband_il_db'], \n                    if2_cfg['rolloff_db_per_dec'], \n                    if2_cfg['stop_floor_db']\n                ))\n        \n        print(f\"  Scanning {len(tasks)} coarse points with {num_workers} workers...\")\n        \n        # Start Pool\n        with Pool(num_workers, initializer=init_worker, initargs=(cfg, stack_def)) as p:\n            results = p.map(evaluate_wrapper, tasks)\n        \n        # Sort and Pick Top K\n        results.sort(key=lambda x: x[0], reverse=True)\n        top_seeds = results[:TOP_K_SEEDS]\n        \n        print(f\"  Top {len(top_seeds)} Coarse Seeds selected for refinement.\")\n        \n        # Local Refinement on Top K\n        hw = HardwareStack(cfg, stack_def)\n        engine = SpurEngine(cfg, hw)\n        \n        for seed_score, seed_model in top_seeds:\n            if seed_score <= -900: continue # Skip dead seeds\n            \n            refined_model, refined_score = local_refinement(engine, seed_model, seed_score)\n            \n            if refined_score > best_global_score:\n                best_global_score = refined_score\n                best_global_setup = (stack_def, refined_model)\n                print(f\"  {Fore.YELLOW}New Global Best: {best_global_score:.2f} dB (IF2: {refined_model.center_hz/1e9:.3f} GHz){Style.RESET_ALL}\")\n\n    if not best_global_setup:\n        print(\"No solution found.\")\n        return\n\n    stack_def, final_if2 = best_global_setup\n    hw = HardwareStack(cfg, stack_def)\n    engine = SpurEngine(cfg, hw)\n    \n    print(f\"\\n{Fore.YELLOW}Final Selected Config: Margin {best_global_score:.2f} dB{Style.RESET_ALL}\")\n    print(f\"Stack: {stack_def['name']}\")\n    print(f\"IF2 Center: {final_if2.center_hz/1e9:.4f} GHz, BW: {final_if2.bw_hz/1e6:.1f} MHz\")\n    \n    # 2. Generate Policy\n    df_policy = build_policy_csv(engine, final_if2, cfg.tiles)\n    df_policy.to_csv(\"final_policy.csv\", index=False)\n    print(\"Policy saved to final_policy.csv\")\n    \n    # 3. Visualization\n    plot_margin_heatmap(df_policy)\n    \n    # 4. Diagnostics\n    valid_rows = df_policy[df_policy['margin'] > -900]\n    if not valid_rows.empty:\n        worst_row = valid_rows.loc[valid_rows['margin'].idxmin()]\n        print(f\"\\nRunning Diagnostics for Worst Case: Tile {worst_row['tile_id']} (Margin {worst_row['margin']:.2f} dB)\")\n        \n        # Refresh LUT in main engine\n        engine.evaluate_policy(final_if2, search_mode=False) # Re-triggers LUT fill\n\n        ledger = generate_spur_ledger(engine, int(worst_row['tile_id']), worst_row, final_if2)\n        if not ledger.empty:\n            print(ledger.head(10).to_string(index=False))\n            ledger.to_csv(\"worst_case_ledger.csv\", index=False)\n            print(f\"Detailed ledger saved to worst_case_ledger.csv\")\n\nif __name__ == \"__main__\":\n    main()",
      "encoding": "utf-8",
      "encoding_error": false
    },
    {
      "type": "file",
      "name": "pyproject.toml",
      "path": "pyproject.toml",
      "size": 311,
      "content_truncated": false,
      "contents": "[project]\nname = \"bucso2-repo\"\nversion = \"0.1.0\"\ndescription = \"Add your description here\"\nreadme = \"README.md\"\nrequires-python = \">=3.13\"\ndependencies = [\n    \"colorama>=0.4.6\",\n    \"matplotlib>=3.10.7\",\n    \"numba>=0.62.1\",\n    \"numpy>=2.3.5\",\n    \"pandas>=2.3.3\",\n    \"pyyaml>=6.0.3\",\n    \"scipy>=1.16.3\",\n]\n",
      "encoding": "utf-8",
      "encoding_error": false
    },
    {
      "type": "file",
      "name": "README.md",
      "path": "README.md",
      "size": 0,
      "content_truncated": false,
      "contents": "",
      "encoding": "utf-8",
      "encoding_error": false
    }
  ]
}