{
  "type": "directory",
  "name": "bucso2_repo",
  "path": ".",
  "children": [
    {
      "type": "directory",
      "name": "src",
      "path": "src",
      "children": [
        {
          "type": "directory",
          "name": "buc",
          "path": "src\\buc",
          "children": [
            {
              "type": "file",
              "name": "__init__.py",
              "path": "src\\buc\\__init__.py",
              "size": 1169,
              "content_truncated": false,
              "contents": "# src/buc/__init__.py\r\n\r\nfrom .buc_structures import (\r\n    GlobalConfig,\r\n    Tile,\r\n    FilterModel,\r\n    MixerModel,\r\n    SynthesizerModel,\r\n    LO_Candidate,\r\n    TilePolicyEntry,\r\n)\r\n\r\nfrom .buc_models import HardwareStack\r\nfrom .buc_engine import SpurEngine\r\nfrom .buc_diagnostics import generate_spur_ledger\r\nfrom .buc_visuals import plot_margin_heatmap, plot_if2_filter\r\nfrom .buc_markov import markov_lock_summary\r\nfrom .buc_validation import basic_validation\r\n\r\nfrom .buc_kernels import (\r\n    build_dense_lut,\r\n    fill_symmetric_filter_lut,\r\n    precompute_mixing_recipes,\r\n    compute_stage1_spurs_no_if2,\r\n    compute_stage2_from_intermediates,\r\n)\r\n\r\n__all__ = [\r\n    \"GlobalConfig\",\r\n    \"Tile\",\r\n    \"FilterModel\",\r\n    \"MixerModel\",\r\n    \"SynthesizerModel\",\r\n    \"LO_Candidate\",\r\n    \"TilePolicyEntry\",\r\n    \"HardwareStack\",\r\n    \"SpurEngine\",\r\n    \"generate_spur_ledger\",\r\n    \"plot_margin_heatmap\",\r\n    \"plot_if2_filter\",\r\n    \"markov_lock_summary\",\r\n    \"basic_validation\",\r\n    \"build_dense_lut\",\r\n    \"fill_symmetric_filter_lut\",\r\n    \"precompute_mixing_recipes\",\r\n    \"compute_stage1_spurs_no_if2\",\r\n    \"compute_stage2_from_intermediates\",\r\n]\r\n",
              "encoding": "utf-8",
              "encoding_error": false
            },
            {
              "type": "file",
              "name": "buc_diagnostics.py",
              "path": "src\\buc\\buc_diagnostics.py",
              "size": 17247,
              "content_truncated": false,
              "contents": "import pandas as pd\r\nimport numpy as np\r\nfrom .buc_structures import Tile, FilterModel\r\nfrom .buc_kernels import get_lut_val\r\n\r\n\r\ndef generate_spur_ledger(\r\n    engine,\r\n    tile_id,\r\n    policy_row,\r\n    if2_filter: FilterModel,\r\n    report_threshold_db: float = 10.0,\r\n):\r\n    \"\"\"\r\n    Build a detailed spur ledger for a single tile / policy setting.\r\n    \"\"\"\r\n    tile = next(t for t in engine.cfg.tiles if t.id == tile_id)\r\n    lo1_freq = policy_row['lo1_hz']\r\n    lo2_freq = policy_row['lo2_hz']\r\n    noise_floor = engine.noise_floor\r\n    max_spur_dbc = engine.cfg.max_spur_level_dbc\r\n\r\n    # Regenerate raw spectra\r\n    lo1_spec = engine.hw.generate_lo_spectrum(engine.hw.lo1_def, lo1_freq)\r\n    lo2_spec = engine.hw.generate_lo_spectrum(engine.hw.lo2_def, lo2_freq)\r\n\r\n    _, _, p1 = engine.hw.get_valid_lo_config(\r\n        engine.hw.lo1_def, lo1_freq, engine.hw.mixer1.drive_req\r\n    )\r\n    _, _, p2 = engine.hw.get_valid_lo_config(\r\n        engine.hw.lo2_def, lo2_freq, engine.hw.mixer2.drive_req\r\n    )\r\n\r\n    corr1 = (p1 - engine.hw.mixer1.nom_drive_dbm) * engine.hw.mixer1.scaling_slope\r\n    corr1 = max(-engine.hw.mixer1.scaling_cap,\r\n                min(engine.hw.mixer1.scaling_cap, corr1))\r\n\r\n    corr2 = (p2 - engine.hw.mixer2.nom_drive_dbm) * engine.hw.mixer2.scaling_slope\r\n    corr2 = max(-engine.hw.mixer2.scaling_cap,\r\n                min(engine.hw.mixer2.scaling_cap, corr2))\r\n\r\n    side_str = policy_row.get('lo1_side', 'low')\r\n    is_sum_mix = (side_str == 'low')\r\n\r\n    # IF1 harmonic model, kept consistent with the engine.\r\n    if1_harmonics = getattr(engine.cfg, \"if1_harmonics\", None)\r\n    if not if1_harmonics:\r\n        if1_harmonics = [(1, 0.0)]\r\n\r\n    # High-level chain sense + desired path formulas\r\n    chain_sense = \"Sum-Sum\" if is_sum_mix else \"Diff-Diff\"\r\n    if is_sum_mix:\r\n        desired_s1_formula = \"f_IF2_desired = f_LO1 + f_IF1\"\r\n        desired_s2_formula = \"f_RF_desired  = f_LO2 + f_IF2\"\r\n    else:\r\n        desired_s1_formula = \"f_IF2_desired = |f_LO1 - f_IF1|\"\r\n        desired_s2_formula = \"f_RF_desired  = |f_LO2 - f_IF2|\"\r\n\r\n    ledger = []\r\n\r\n    def add_entry(\r\n        source_stage: str,\r\n        stage_lbl,\r\n        formula: str,\r\n        freq_hz: float,\r\n        level_db: float,\r\n        limit_db: float,\r\n        stage1_m: float | None = None,\r\n        stage1_n: float | None = None,\r\n        stage2_m: float | None = None,\r\n        stage2_n: float | None = None,\r\n    ):\r\n        \"\"\"\r\n        Helper to append a row with full context.\r\n        \"\"\"\r\n        margin = limit_db - level_db - engine.cfg.yaml_data['constraints']['guard_margin_db']\r\n\r\n        # Combined spur \"order\" across stages, when known\r\n        total_order = None\r\n        if stage1_m is not None and stage1_n is not None:\r\n            total_order = abs(stage1_m) + abs(stage1_n)\r\n        if stage2_m is not None and stage2_n is not None:\r\n            stage2_order = abs(stage2_m) + abs(stage2_n)\r\n            total_order = (total_order or 0) + stage2_order\r\n\r\n        ledger.append({\r\n            # --- Tile & filter context ---\r\n            \"Tile_ID\": tile.id,\r\n            \"IF1_center_GHz\": tile.if1_center_hz / 1e9,\r\n            \"BW_MHz\": tile.bw_hz / 1e6,\r\n            \"RF_center_GHz\": tile.rf_center_hz / 1e9,\r\n            \"IF2_center_GHz\": if2_filter.center_hz / 1e9,\r\n            \"IF2_bw_MHz\": if2_filter.bw_hz / 1e6,\r\n\r\n            # --- LO context ---\r\n            \"LO1_GHz\": lo1_freq / 1e9,\r\n            \"LO2_GHz\": lo2_freq / 1e9,\r\n\r\n            # --- Desired-path context ---\r\n            \"Chain_Sense\": chain_sense,                # \"Sum-Sum\" or \"Diff-Diff\"\r\n            \"Desired_S1_Formula\": desired_s1_formula,  # IF1 -> IF2 desired mapping\r\n            \"Desired_S2_Formula\": desired_s2_formula,  # IF2 -> RF desired mapping\r\n\r\n            # --- Spur identification ---\r\n            \"Source_Stage\": source_stage,\r\n            \"Stage\": stage_lbl,         # 2 or \"1+2\"\r\n            \"Stage1_m\": stage1_m,\r\n            \"Stage1_n\": stage1_n,\r\n            \"Stage2_m\": stage2_m,\r\n            \"Stage2_n\": stage2_n,\r\n            \"Total_Order\": total_order,\r\n\r\n            # --- Numeric results ---\r\n            \"Freq_GHz\": freq_hz / 1e9,\r\n            \"Level_dBm_equiv\": level_db,\r\n            \"Limit_dBc\": limit_db,\r\n            \"Margin_dB\": margin,\r\n\r\n            # --- Human-readable spur formula ---\r\n            \"Formula\": formula,\r\n        })\r\n\r\n    # Desired IF2 tone and tolerance for desired-path detection\r\n    f_if2_desired = if2_filter.center_hz\r\n    tol_if2 = max(100.0, engine.grid_step)  # same spirit as engine: small but >0\r\n\r\n    # (f_if2, level_at_if2, formula, m1, n1, source_tag)\r\n    stage1_spurs = []\r\n\r\n    # ------------------------------------------------------------------\r\n    # A. Stage-1 spurs at IF2 (used as input to Stage-2 leakage paths)\r\n    # ------------------------------------------------------------------\r\n    # 1) LO-only families (n == 0) – independent of IF1 and its harmonics.\r\n    for k in range(len(lo1_spec)):\r\n        f_lo_c, p_lo_c = lo1_spec[k]\r\n        lo_tag = \"LO1\" if k == 0 else \"LO1H\"\r\n\r\n        for row in engine.hw.mixer1.spur_table_np:\r\n            m, n, base_rej = int(row[0]), int(row[1]), row[2]\r\n            rej = base_rej - corr1\r\n            lvl = p_lo_c + rej\r\n\r\n            if n != 0:\r\n                continue  # not LO-only\r\n\r\n            # Pure LO tone at m * f_LO1\r\n            f_spur_if2 = abs(m * f_lo_c)\r\n            atten_if2 = get_lut_val(\r\n                f_spur_if2, engine.if2_lut_buffer, engine.grid_step\r\n            )\r\n            lvl_input = lvl - atten_if2\r\n            if lvl_input < noise_floor:\r\n                continue\r\n\r\n            formula = f\"({m}*{lo_tag})\"\r\n            stage1_spurs.append(\r\n                (f_spur_if2, lvl_input, formula, m, n, \"LO-only\")\r\n            )\r\n\r\n    # 2) IF-dependent families (n > 0) for each IF1 harmonic.\r\n    for k_if, rel_if_dbc in if1_harmonics:\r\n        if1_freq = k_if * tile.if1_center_hz\r\n\r\n        for k in range(len(lo1_spec)):\r\n            f_lo_c, p_lo_c = lo1_spec[k]\r\n            is_main = (k == 0)\r\n            lo_tag = \"LO1\" if k == 0 else \"LO1H\"\r\n\r\n            for row in engine.hw.mixer1.spur_table_np:\r\n                m, n, base_rej = int(row[0]), int(row[1]), row[2]\r\n                if n == 0:\r\n                    continue  # LO-only; already handled\r\n\r\n                rej = base_rej - corr1\r\n                lvl = p_lo_c + rej  # base mixer spur level\r\n\r\n                eff_lo = m * f_lo_c\r\n\r\n                # PURE IF BUGFIX: avoid double-counting for m == 0, n != 0.\r\n                pure_if_family = (m == 0 and n != 0)\r\n                s_if_values = (1,) if pure_if_family else (-1, 1)\r\n\r\n                for s_if in s_if_values:\r\n                    # Desired-path detection only for the fundamental harmonic.\r\n                    is_desired = False\r\n                    if (k_if == 1) and is_main and m == 1 and n == 1:\r\n                        f_candidate = abs(eff_lo + s_if * n * if1_freq)\r\n                        if abs(f_candidate - f_if2_desired) < tol_if2:\r\n                            is_desired = True\r\n\r\n                    if is_desired:\r\n                        continue\r\n\r\n                    f_spur_if2 = abs(eff_lo + s_if * n * if1_freq)\r\n                    atten_if2 = get_lut_val(\r\n                        f_spur_if2, engine.if2_lut_buffer, engine.grid_step\r\n                    )\r\n\r\n                    # Apply harmonic amplitude offset rel_if_dbc (typically ≤ 0 dB)\r\n                    lvl_input = (lvl + rel_if_dbc) - atten_if2\r\n                    if lvl_input < noise_floor:\r\n                        continue\r\n\r\n                    sign_if = \"+\" if s_if > 0 else \"-\"\r\n                    formula = f\"({m}*{lo_tag} {sign_if} {n}*IF1_k={k_if})\"\r\n\r\n                    source_tag = f\"IF1 k={k_if}\"\r\n                    stage1_spurs.append(\r\n                        (f_spur_if2, lvl_input, formula, m, n, source_tag)\r\n                    )\r\n\r\n    # ------------------------------------------------------------------\r\n    # B. Direct Stage-2 spurs from desired IF2 tone\r\n    # ------------------------------------------------------------------\r\n    for k in range(len(lo2_spec)):\r\n        f_lo_c, p_lo_c = lo2_spec[k]\r\n        lo_tag = \"LO2\" if k == 0 else \"LO2H\"\r\n\r\n        for row in engine.hw.mixer2.spur_table_np:\r\n            m, n, base_rej = int(row[0]), int(row[1]), row[2]\r\n            rej = base_rej - corr2\r\n            lvl = p_lo_c + rej  # LO comp + scaled rejection\r\n\r\n            # n == 0 : pure LO term (no dependence on IF2)\r\n            if n == 0:\r\n                f_spur_rf = abs(m * f_lo_c)\r\n                atten_rf = get_lut_val(f_spur_rf, engine.rf_lut, engine.grid_step)\r\n                final_lvl = lvl - atten_rf\r\n                if final_lvl < noise_floor:\r\n                    continue\r\n\r\n                limit = get_lut_val(f_spur_rf, engine.mask_lut, engine.grid_step)\r\n                if (limit - final_lvl) < report_threshold_db:\r\n                    formula = f\"({m}*{lo_tag})\"\r\n                    add_entry(\r\n                        \"Direct (S2)\",\r\n                        2,\r\n                        formula,\r\n                        f_spur_rf,\r\n                        final_lvl,\r\n                        limit,\r\n                        stage1_m=1,\r\n                        stage1_n=1,\r\n                        stage2_m=m,\r\n                        stage2_n=n,\r\n                    )\r\n                continue\r\n\r\n            # n > 0 : ±IF2 products (sum/diff), LO sign removed\r\n            eff_lo = m * f_lo_c  # +m * LO2\r\n\r\n            # --- PURE-IF BUGFIX HERE (Stage-2) --------------------------\r\n            # Same reasoning as Stage-1: for m == 0, ±n collapses to a\r\n            # pure-IF2 spur at |n|*f_IF2, so only generate one sign.\r\n            pure_if_family = (m == 0 and n != 0)\r\n            s_if_values = (1,) if pure_if_family else (-1, 1)\r\n            # ------------------------------------------------------------\r\n\r\n            for s_if in s_if_values:\r\n                f_spur_rf = abs(eff_lo + s_if * n * f_if2_desired)\r\n\r\n                # Filter out the *desired* RF carrier (main LO, m=1, n=1 @ RF center)\r\n                if (k == 0 and m == 1 and n == 1 and\r\n                        abs(f_spur_rf - tile.rf_center_hz) < 1000.0):\r\n                    continue\r\n\r\n                atten_rf = get_lut_val(f_spur_rf, engine.rf_lut, engine.grid_step)\r\n                final_lvl = lvl - atten_rf\r\n                if final_lvl < noise_floor:\r\n                    continue\r\n\r\n                limit = get_lut_val(f_spur_rf, engine.mask_lut, engine.grid_step)\r\n                if (limit - final_lvl) < report_threshold_db:\r\n                    sign_if = \"+\" if s_if > 0 else \"-\"\r\n                    formula = f\"({m}*{lo_tag} {sign_if} {n}*IF2_desired)\"\r\n                    # Stage-1 is the desired (1,1) path here; Stage-2 is (m,n)\r\n                    add_entry(\r\n                        \"Direct (S2)\",\r\n                        2,\r\n                        formula,\r\n                        f_spur_rf,\r\n                        final_lvl,\r\n                        limit,\r\n                        stage1_m=1,\r\n                        stage1_n=1,\r\n                        stage2_m=m,\r\n                        stage2_n=n,\r\n                    )\r\n\r\n    # ------------------------------------------------------------------\r\n    # C. Stage-1 leakage spurs mixed again in Stage-2\r\n    # ------------------------------------------------------------------\r\n    for sp_f, sp_l, sp_form, m1, n1, src_tag in stage1_spurs:\r\n        # Apply clamp\r\n        l_eff = sp_l\r\n        if l_eff > max_spur_dbc:\r\n            l_eff = max_spur_dbc\r\n\r\n        for k in range(len(lo2_spec)):\r\n            f_lo_c, p_lo_c = lo2_spec[k]\r\n            lo_tag = \"LO2\" if k == 0 else \"LO2H\"\r\n\r\n            for row in engine.hw.mixer2.spur_table_np:\r\n                m, n, base_rej = int(row[0]), int(row[1]), row[2]\r\n                rej = base_rej - corr2\r\n\r\n                lvl_stage2 = p_lo_c + rej\r\n                eff_lo = m * f_lo_c  # +m * LO2\r\n\r\n                # n == 0 : pure LO spur; no dependence on sp_f\r\n                if n == 0:\r\n                    f_final_rf = abs(eff_lo)\r\n                    atten_rf = get_lut_val(f_final_rf, engine.rf_lut, engine.grid_step)\r\n                    lvl_rf = l_eff + lvl_stage2\r\n                    final_lvl = lvl_rf - atten_rf\r\n                    if final_lvl < noise_floor:\r\n                        continue\r\n\r\n                    limit = get_lut_val(f_final_rf, engine.mask_lut, engine.grid_step)\r\n                    if (limit - final_lvl) < report_threshold_db:\r\n                        formula = f\"{m}*{lo_tag}\"\r\n                        add_entry(\r\n                            f\"Leakage (S1->S2, {src_tag})\",\r\n                            \"1+2\",\r\n                            formula,\r\n                            f_final_rf,\r\n                            final_lvl,\r\n                            limit,\r\n                            stage1_m=m1,\r\n                            stage1_n=n1,\r\n                            stage2_m=m,\r\n                            stage2_n=n,\r\n                        )\r\n                    continue\r\n\r\n                # n > 0 : two sum/diff products relative to the Stage-1 spur\r\n                # (We intentionally keep ±n here, even for m=0; Stage-1\r\n                #  has already de-duplicated pure-IF families so we won't\r\n                #  hit the same 2× double-counting here.)\r\n                for s_if in (-1, 1):\r\n                    f_final_rf = abs(eff_lo + s_if * n * sp_f)\r\n\r\n                    lvl_rf = l_eff + lvl_stage2  # S1 level (dB) + S2 gain (dB)\r\n                    atten_rf = get_lut_val(f_final_rf, engine.rf_lut, engine.grid_step)\r\n                    final_lvl = lvl_rf - atten_rf\r\n\r\n                    if final_lvl < noise_floor:\r\n                        continue\r\n\r\n                    limit = get_lut_val(f_final_rf, engine.mask_lut, engine.grid_step)\r\n\r\n                    if (limit - final_lvl) < report_threshold_db:\r\n                        clean_sp_form = sp_form.replace(\"(\", \"\").replace(\")\", \"\")\r\n                        sign_if = \"+\" if s_if > 0 else \"-\"\r\n                        formula = f\"{m}*{lo_tag} {sign_if} {n}*[{clean_sp_form}]\"\r\n                        add_entry(\r\n                            f\"Leakage (S1->S2, {src_tag})\",\r\n                            \"1+2\",\r\n                            formula,\r\n                            f_final_rf,\r\n                            final_lvl,\r\n                            limit,\r\n                            stage1_m=m1,\r\n                            stage1_n=n1,\r\n                            stage2_m=m,\r\n                            stage2_n=n,\r\n                        )\r\n\r\n    # ------------------------------------------------------------------\r\n    # D. Mixer-2 IF→RF isolation as a direct RF-port spur\r\n    # ------------------------------------------------------------------\r\n    if engine.hw.mixer2.include_isolation_spurs:\r\n        f_if2_leak = float(if2_filter.center_hz)\r\n        if f_if2_leak > 0.0:\r\n            # RF filter attenuation at IF2-like frequency\r\n            atten_rf = get_lut_val(f_if2_leak, engine.rf_lut, engine.grid_step)\r\n            iso_db = engine.hw.mixer2.if_feedthrough_rej_db()  # e.g. -45 dBc\r\n            final_lvl = iso_db - atten_rf\r\n\r\n            if final_lvl >= noise_floor:\r\n                limit = get_lut_val(f_if2_leak, engine.mask_lut, engine.grid_step)\r\n\r\n                # Only report if it is within the reporting window\r\n                if (limit - final_lvl) < report_threshold_db:\r\n                    add_entry(\r\n                        source_stage=\"IF→RF Isolation (S2)\",\r\n                        stage_lbl=2,\r\n                        formula=\"IF2_leakage (no mixing)\",\r\n                        freq_hz=f_if2_leak,\r\n                        level_db=final_lvl,\r\n                        limit_db=limit,\r\n                        stage1_m=None,\r\n                        stage1_n=None,\r\n                        stage2_m=None,\r\n                        stage2_n=None,\r\n                    )\r\n\r\n    df = pd.DataFrame(ledger)\r\n    if not df.empty:\r\n        # Expanded column set; old columns are preserved so downstream\r\n        # tooling that expects them still works.\r\n        cols = [\r\n            # Context\r\n            \"Tile_ID\",\r\n            \"IF1_center_GHz\", \"BW_MHz\", \"RF_center_GHz\",\r\n            \"IF2_center_GHz\", \"IF2_bw_MHz\",\r\n            \"LO1_GHz\", \"LO2_GHz\",\r\n            \"Chain_Sense\",\r\n            \"Desired_S1_Formula\", \"Desired_S2_Formula\",\r\n\r\n            # Spur identification\r\n            \"Source_Stage\", \"Stage\",\r\n            \"Stage1_m\", \"Stage1_n\",\r\n            \"Stage2_m\", \"Stage2_n\",\r\n            \"Total_Order\",\r\n\r\n            # Numeric results (old core columns)\r\n            \"Freq_GHz\",\r\n            \"Margin_dB\",\r\n            \"Level_dBm_equiv\",\r\n            \"Limit_dBc\",\r\n\r\n            # Human-readable spur expression\r\n            \"Formula\",\r\n        ]\r\n        # Keep only the columns we defined (defensive in case of typos)\r\n        cols = [c for c in cols if c in df.columns]\r\n        df = df[cols].sort_values(\"Margin_dB\", ascending=True)\r\n\r\n    return df\r\n",
              "encoding": "utf-8",
              "encoding_error": false
            },
            {
              "type": "file",
              "name": "buc_engine.py",
              "path": "src\\buc\\buc_engine.py",
              "size": 31653,
              "content_truncated": false,
              "contents": "import numpy as np\r\nfrom .buc_structures import Tile, FilterModel, LO_Candidate, TilePolicyEntry\r\nfrom .buc_kernels import (\r\n    build_dense_lut, \r\n    fill_symmetric_filter_lut, \r\n    fill_scaled_s2p_lut,\r\n    precompute_mixing_recipes,\r\n    get_lut_val,\r\n    compute_stage1_spurs_no_if2,\r\n    compute_stage2_from_intermediates\r\n)\r\n\r\nclass SpurEngine:\r\n    BRITTLENESS_STEP_HZ = 1e6\r\n\r\n    def __init__(self, config, hw_stack):\r\n        self.cfg = config\r\n        self.hw = hw_stack\r\n        self.grid_max = self.cfg.grid_max_freq_hz\r\n        self.grid_step = self.cfg.grid_step_hz\r\n        self.opt_cutoff = self.cfg.opt_cutoff_db\r\n        self.noise_floor = self.cfg.noise_floor_dbc\r\n        self.guard_db = float(self.cfg.yaml_data['constraints']['guard_margin_db'])\r\n        \r\n        self.rbw_hz = self.cfg.rbw_hz\r\n        self.max_order_stage1 = int(self.cfg.m1_max_order)\r\n        self.max_order_stage2 = int(self.cfg.m2_max_order)\r\n        self.hysteresis_hz = float(self.cfg.hysteresis_hz)\r\n        self.cross_stage_sum_max = int(self.cfg.cross_stage_sum_max)\r\n\r\n        self.enforce_non_inverting = bool(\r\n            self.cfg.yaml_data.get('constraints', {}).get('enforce_non_inverting_chain', True)\r\n        )\r\n        if not self.enforce_non_inverting:\r\n            raise NotImplementedError(\r\n                \"enforce_non_inverting_chain=False is not supported.\"\r\n            )\r\n        \r\n        self.stage1_buffer_size = 65536 \r\n        self.stage1_buffer = np.zeros((self.stage1_buffer_size, 4), dtype=np.float64)\r\n        \r\n        self.stage1_raw_buffer_size = 65536\r\n        self.stage1_raw_buffer = np.zeros((self.stage1_raw_buffer_size, 4), dtype=np.float64)\r\n        self.stage1_raw_cache = {}\r\n        \r\n        self._lo1_cand_cache = {}\r\n        self._lo2_cand_cache = {}\r\n\r\n        # Build Mask LUT with Slope Support\r\n        mask_oob_def = self.cfg.yaml_data['masks']['outofband']['default_dbc']\r\n        self.mask_lut = np.full(int(self.grid_max/self.grid_step)+2, mask_oob_def, dtype=np.float32)\r\n        \r\n        ib_cfg = self.cfg.yaml_data['masks']['inband']\r\n        rf_min, rf_max = self.cfg.yaml_data['bands']['rf_hz']['min'], self.cfg.yaml_data['bands']['rf_hz']['max']\r\n        idx_min, idx_max = int(rf_min / self.grid_step), int(rf_max / self.grid_step)\r\n        if idx_min < len(self.mask_lut) and idx_max < len(self.mask_lut):\r\n            self.mask_lut[idx_min:idx_max] = float(ib_cfg['default_dbc'])\r\n            \r\n        def _apply_mask_table(table, default_step, lut):\r\n            for entry in table:\r\n                if 'freq_hz' in entry and 'limit_dbc' in entry:\r\n                    f = float(entry['freq_hz'])\r\n                    idx = int(f / default_step)\r\n                    if 0 <= idx < len(lut):\r\n                        lut[idx] = float(entry['limit_dbc'])\r\n                elif all(k in entry for k in ('start_hz', 'stop_hz', 'limit_dbc')):\r\n                    f0 = float(entry['start_hz'])\r\n                    f1 = float(entry['stop_hz'])\r\n                    idx0 = max(0, int(f0 / default_step))\r\n                    idx1 = min(len(lut), int(f1 / default_step))\r\n                    lut[idx0:idx1] = float(entry['limit_dbc'])\r\n                # Support Sloped Masks\r\n                elif all(k in entry for k in ('start_hz', 'stop_hz', 'start_limit_dbc', 'stop_limit_dbc')):\r\n                    f0 = float(entry['start_hz'])\r\n                    f1 = float(entry['stop_hz'])\r\n                    l0 = float(entry['start_limit_dbc'])\r\n                    l1 = float(entry['stop_limit_dbc'])\r\n                    idx0 = max(0, int(f0 / default_step))\r\n                    idx1 = min(len(lut), int(f1 / default_step))\r\n                    length = max(1, idx1 - idx0)\r\n                    for i in range(idx0, idx1):\r\n                        t = (i - idx0) / max(1, length - 1)\r\n                        lut[i] = l0 + t * (l1 - l0)\r\n\r\n        _apply_mask_table(ib_cfg.get('table', []), self.grid_step, self.mask_lut)\r\n        _apply_mask_table(self.cfg.yaml_data['masks']['outofband'].get('table', []),\r\n                          self.grid_step, self.mask_lut)\r\n        \r\n        self.rf_lut = build_dense_lut(\r\n            self.cfg.rf_filter_raw_freqs,\r\n            self.cfg.rf_filter_raw_atten,\r\n            self.grid_max, self.grid_step, 80.0\r\n        )\r\n        self.rf_passband_lo_hz, self.rf_passband_hi_hz = self._estimate_rf_passband(\r\n            self.rf_lut, self.grid_step\r\n        )\r\n        \r\n        self.if2_lut_buffer = np.zeros_like(self.rf_lut)\r\n        self.lo_cache = {}      \r\n        self.recipe_cache = {} \r\n        self._warmup_jit()\r\n\r\n    def _eval_if_iso_mixer2_leakage(self, if2_filter: FilterModel) -> float:\r\n        \"\"\"\r\n        Model Mixer-2 IF→RF isolation as a direct RF-port spur that\r\n        appears near the IF2 centre frequency, then is shaped by the\r\n        RF BPF and checked against the mask.\r\n\r\n        Returns a \"margin\" for this path. The caller should take the\r\n        minimum of this and the main spur margin.\r\n        \"\"\"\r\n        # Respect the global isolation flag\r\n        if not self.hw.mixer2.include_isolation_spurs:\r\n            return 999.0  # effectively no constraint\r\n\r\n        f_if2 = float(if2_filter.center_hz)\r\n        if f_if2 <= 0.0:\r\n            return 999.0\r\n\r\n        # Check against LUT extent\r\n        idx = int(f_if2 / self.grid_step)\r\n        if idx < 0 or idx >= self.mask_lut.shape[0]:\r\n            return 999.0\r\n\r\n        # IF→RF isolation is already defined as a RF-port spur level\r\n        iso_db = self.hw.mixer2.if_feedthrough_rej_db()  # e.g. -45 dBc\r\n\r\n        # RF filter attenuation at that IF2-like frequency\r\n        atten_rf = get_lut_val(f_if2, self.rf_lut, self.grid_step)\r\n        final_lvl = iso_db - atten_rf  # dBc after RF BPF\r\n\r\n        # If well below noise floor, it is irrelevant\r\n        if final_lvl < self.noise_floor:\r\n            return 999.0\r\n\r\n        limit = self.mask_lut[idx]\r\n        margin = limit - final_lvl - self.guard_db\r\n        return float(margin)\r\n\r\n    def _estimate_rf_passband(self, lut, step_hz):\r\n        \"\"\"Config-driven estimation with LUT validation.\"\"\"\r\n        rf_cfg = self.cfg.yaml_data['bands']['rf_hz']\r\n        rf_min_cfg, rf_max_cfg = rf_cfg['min'], rf_cfg['max']\r\n        idx_min_cfg, idx_max_cfg = int(rf_min_cfg / step_hz), int(rf_max_cfg / step_hz)\r\n\r\n        max_inband = self.cfg.rf_passband_max_atten_db\r\n\r\n        lo_idx, hi_idx = -1, -1\r\n        limit = min(idx_max_cfg, len(lut))\r\n        \r\n        for i in range(idx_min_cfg, limit):\r\n            if lut[i] <= max_inband:\r\n                if lo_idx < 0: lo_idx = i\r\n                hi_idx = i\r\n\r\n        if lo_idx < 0:\r\n            return rf_min_cfg, rf_max_cfg\r\n\r\n        f_lo = lo_idx * step_hz\r\n        f_hi = hi_idx * step_hz\r\n        \r\n        cfg_span = rf_max_cfg - rf_min_cfg\r\n        lut_span = f_hi - f_lo\r\n\r\n        if lut_span < 0.2 * cfg_span:\r\n            print(\"Warning: RF LUT passband narrower than 20% of config span; using config RF range.\")\r\n            return rf_min_cfg, rf_max_cfg\r\n\r\n        return f_lo, f_hi\r\n\r\n    def _warmup_jit(self):\r\n        dummy_lut = np.zeros(100, dtype=np.float32)\r\n        get_lut_val(50.0, dummy_lut, 1.0)\r\n        dummy_recipes = np.zeros((10, 6), dtype=np.float64)\r\n        dummy_stage1 = np.zeros((10, 4), dtype=np.float64)\r\n        compute_stage1_spurs_no_if2(dummy_recipes, 1e9, dummy_stage1)\r\n        compute_stage2_from_intermediates(\r\n            dummy_stage1, dummy_recipes, 30e9, 5e9, \r\n            dummy_lut, dummy_lut, 1e6, 2.0, -100.0, 1e6, 12, 0.0\r\n        )\r\n\r\n    def _get_lo_data(self, lo_def, freq, mixer_model, delivered_power, search_mode, max_order, dominant_only=False):\r\n        p_round = round(delivered_power, 2)\r\n        # Cache Key includes dominant_only flag\r\n        key = (\r\n            freq, lo_def.name, p_round, int(search_mode), max_order, \r\n            lo_def.mode_name, 1, 1, int(dominant_only)\r\n        )\r\n        \r\n        if key not in self.lo_cache:\r\n            # Generate spec using f_pfd from model (Phase-1 assumption)\r\n            spec = self.hw.generate_lo_spectrum(lo_def, freq)\r\n            drive_delta = delivered_power - mixer_model.nom_drive_dbm\r\n            recipes = precompute_mixing_recipes(\r\n                spec, \r\n                mixer_model.spur_table_np, \r\n                search_mode,\r\n                drive_delta,\r\n                mixer_model.scaling_slope,\r\n                mixer_model.scaling_cap,\r\n                max_order,\r\n                include_lo_feedthrough=mixer_model.include_isolation_spurs,\r\n                lo_feedthrough_rej_db=mixer_model.lo_feedthrough_rej_db(),\r\n                dominant_only=dominant_only\r\n            )\r\n            self.lo_cache[key] = spec\r\n            self.recipe_cache[key] = recipes\r\n            \r\n        return self.lo_cache[key], self.recipe_cache[key]\r\n\r\n    def _quantize_lo_freq(self, lo_model, target_freq):\r\n        step = lo_model.step_hz\r\n        if step <= 0.0: return target_freq\r\n        n = round(target_freq / step)\r\n        return n * step\r\n\r\n    def _get_lo_candidate(self, lo_model, cache, target_freq, mixer_model):\r\n        q_freq = self._quantize_lo_freq(lo_model, target_freq)\r\n        key = q_freq\r\n        if key in cache: return cache[key]\r\n\r\n        valid, pad, p_del = self.hw.get_valid_lo_config(\r\n            lo_model, q_freq, mixer_model.drive_req\r\n        )\r\n        if not valid:\r\n            cache[key] = None\r\n            return None\r\n\r\n        cand = LO_Candidate(\r\n            freq_hz=q_freq,\r\n            mode=lo_model.mode_name,\r\n            side=\"unknown\",\r\n            delivered_power_dbm=p_del,\r\n            pad_db=pad,\r\n            spectrum=np.empty((0, 2), dtype=np.float64),\r\n        )\r\n        cache[key] = cand\r\n        return cand\r\n\r\n    def _get_stage1_spurs_raw(\r\n        self,\r\n        tile,\r\n        lo1_freq: float,\r\n        is_sum_mix: bool,\r\n        recipes1: np.ndarray,\r\n        search_mode: int,\r\n        dominant_only: bool,\r\n    ) -> np.ndarray:\r\n        \"\"\"\r\n        Compute Stage-1 spurs at the Mixer-1 output, including IF1 harmonics.\r\n\r\n        Returns a numpy array with columns:\r\n          [0] f_if2_Hz\r\n          [1] level_dBc (pre-IF2, relative to desired)\r\n          [2] m_abs\r\n          [3] n_abs\r\n\r\n        Semantics:\r\n\r\n          - LO-only families (n_abs == 0) are generated ONCE from a base run\r\n            and are NOT scaled by the IF1 harmonic amplitudes.\r\n\r\n          - IF-dependent families (n_abs > 0) are generated once per configured\r\n            IF1 harmonic and are shifted by that harmonic’s rel_dBc.\r\n\r\n          - The IF1 harmonic content comes from cfg.if1_harmonics, a list of\r\n            (k, rel_dBc) pairs.\r\n\r\n        Notes:\r\n\r\n          * is_sum_mix is currently not used here; the mixing sense is encoded\r\n            in the sign of 'signed_n' within the recipes.\r\n        \"\"\"\r\n\r\n        # Normalise harmonic model; also used in the cache key.\r\n        if1_harmonics = getattr(self.cfg, \"if1_harmonics\", None)\r\n        if not if1_harmonics:\r\n            if1_harmonics = [(1, 0.0)]\r\n\r\n        # Cache key includes the harmonic model so that changing the model and\r\n        # reusing the same GlobalConfig object cannot return stale results.\r\n        harmonics_key = tuple(if1_harmonics)\r\n        key = (\r\n            tile.id,\r\n            lo1_freq,\r\n            tile.if1_center_hz,\r\n            int(search_mode),\r\n            1 if is_sum_mix else 0,\r\n            int(dominant_only),\r\n            harmonics_key,\r\n        )\r\n\r\n        if key in self.stage1_raw_cache:\r\n            return self.stage1_raw_cache[key]\r\n\r\n        chunks: list[np.ndarray] = []\r\n\r\n        # --------------------------------------------------------------\r\n        # 1) Base run for LO-only spur families (n_abs == 0).\r\n        #    These terms are independent of IF1 amplitude and frequency.\r\n        #    Any non-zero IF1 frequency would do; we use IF1_center for clarity.\r\n        # --------------------------------------------------------------\r\n        base_if1 = tile.if1_center_hz\r\n\r\n        while True:\r\n            count = compute_stage1_spurs_no_if2(\r\n                recipes1,\r\n                base_if1,\r\n                self.stage1_raw_buffer,\r\n            )\r\n            if count < 0:\r\n                # Grow buffer and retry\r\n                new_size = self.stage1_raw_buffer_size * 2\r\n                self.stage1_raw_buffer = np.zeros((new_size, 4), dtype=np.float64)\r\n                self.stage1_raw_buffer_size = new_size\r\n                continue\r\n            break\r\n\r\n        if count > 0:\r\n            buf = self.stage1_raw_buffer[:count]\r\n            # n_abs is stored in column 3\r\n            mask_lo_only = buf[:, 3] == 0.0\r\n            if np.any(mask_lo_only):\r\n                lo_chunk = buf[mask_lo_only].copy()\r\n                # LO-only entries are NOT scaled by rel_dBc.\r\n                chunks.append(lo_chunk)\r\n\r\n        # --------------------------------------------------------------\r\n        # 2) IF-dependent terms (n_abs > 0) for each IF1 harmonic.\r\n        #    For each (k_if, rel_if_dBc), run the kernel with\r\n        #        if1_freq = k_if * IF1_center\r\n        #    and level-shift those spurs by rel_if_dBc.\r\n        # --------------------------------------------------------------\r\n        for k_if, rel_if_dbc in if1_harmonics:\r\n            if1_freq = float(k_if) * float(tile.if1_center_hz)\r\n\r\n            while True:\r\n                count = compute_stage1_spurs_no_if2(\r\n                    recipes1,\r\n                    if1_freq,\r\n                    self.stage1_raw_buffer,\r\n                )\r\n                if count < 0:\r\n                    new_size = self.stage1_raw_buffer_size * 2\r\n                    self.stage1_raw_buffer = np.zeros((new_size, 4), dtype=np.float64)\r\n                    self.stage1_raw_buffer_size = new_size\r\n                    continue\r\n                break\r\n\r\n            if count <= 0:\r\n                continue\r\n\r\n            buf = self.stage1_raw_buffer[:count]\r\n            mask_if_dep = buf[:, 3] > 0.0\r\n            if not np.any(mask_if_dep):\r\n                continue\r\n\r\n            chunk = buf[mask_if_dep].copy()\r\n\r\n            # Scale by the harmonic amplitude relative to the fundamental.\r\n            # rel_if_dbc is typically <= 0.0; adding it lowers the spur level.\r\n            if rel_if_dbc != 0.0:\r\n                chunk[:, 1] += rel_if_dbc\r\n\r\n            chunks.append(chunk)\r\n\r\n        # --------------------------------------------------------------\r\n        # 3) Stack, cache, and return\r\n        # --------------------------------------------------------------\r\n        if not chunks:\r\n            arr = self.stage1_raw_buffer[:0].copy()\r\n        elif len(chunks) == 1:\r\n            arr = chunks[0]\r\n        else:\r\n            arr = np.vstack(chunks)\r\n\r\n        self.stage1_raw_cache[key] = arr\r\n        return arr\r\n\r\n    # --- Unified Policy Builder ---\r\n    def build_policy_for_if2(\r\n        self,\r\n        if2_filter: FilterModel,\r\n        search_mode: bool = True,\r\n        compute_brittleness: bool = False,\r\n        stop_if_margin_below: float = None,\r\n    ):\r\n        \"\"\"\r\n        Construct policy with hysteresis, heuristic lock time, and pruning.\r\n        \"\"\"\r\n        # 1. Prepare IF2 LUT\r\n        self.if2_lut_buffer[:] = float(if2_filter.stop_floor)\r\n        if if2_filter.model_type == 0:\r\n            fill_symmetric_filter_lut(\r\n                self.if2_lut_buffer, if2_filter.center_hz, if2_filter.bw_hz,\r\n                if2_filter.passband_il, if2_filter.rolloff, if2_filter.stop_floor,\r\n                self.grid_step\r\n            )\r\n        elif if2_filter.model_type == 1 and len(self.cfg.if2_proto_norm_x) > 0:\r\n            fill_scaled_s2p_lut(\r\n                self.if2_lut_buffer, if2_filter.center_hz, if2_filter.bw_hz,\r\n                self.cfg.if2_proto_norm_x, self.cfg.if2_proto_val_y,\r\n                if2_filter.stop_floor, self.grid_step\r\n            )\r\n\r\n        # 2. Determine Traversal Order (RF-snaked)\r\n        sorted_tiles = sorted(self.cfg.tiles, key=lambda t: (t.rf_center_hz, t.if1_center_hz))\r\n        grouped = {}\r\n        for t in sorted_tiles:\r\n            grouped.setdefault(t.rf_center_hz, []).append(t)\r\n        rf_keys = sorted(grouped.keys())\r\n        processing_order = []\r\n        for i, rf in enumerate(rf_keys):\r\n            group = grouped[rf]\r\n            if i % 2 == 1: group = group[::-1]\r\n            processing_order.extend(group)\r\n\r\n        worst_margin = 999.0\r\n        total_lock_time = 0.0\r\n        retune_count = 0\r\n        \r\n        prev_lo1_freq = None\r\n        prev_lo2_freq = None\r\n        prev_side = None\r\n        \r\n        entries = []\r\n\r\n        for tile in processing_order:\r\n            # --- Dominant Pruning ---\r\n            # Check Low Side (Sum-Sum)\r\n            margin_low_approx = self._eval_chain_approx(tile, if2_filter, high_side=False)\r\n            low_viable = True\r\n            if margin_low_approx < (self.cfg.dominant_prune_cutoff_db - self.cfg.dominant_spur_margin_buffer_db):\r\n                low_viable = False\r\n                \r\n            # Check High Side (Diff-Diff)\r\n            margin_high_approx = self._eval_chain_approx(tile, if2_filter, high_side=True)\r\n            high_viable = True\r\n            if margin_high_approx < (self.cfg.dominant_prune_cutoff_db - self.cfg.dominant_spur_margin_buffer_db):\r\n                high_viable = False\r\n\r\n            candidates = []\r\n\r\n            # --- Full (or Search-Mode) Eval for Viable Sides ---\r\n            if low_viable:\r\n                m_sum = self._eval_chain_fast(tile, if2_filter, high_side=False, search_mode=search_mode)\r\n                if m_sum > -900.0:\r\n                    lo1_t = if2_filter.center_hz - tile.if1_center_hz\r\n                    lo2_t = tile.rf_center_hz - if2_filter.center_hz\r\n                    c1 = self._get_lo_candidate(self.hw.lo1_def, self._lo1_cand_cache, lo1_t, self.hw.mixer1)\r\n                    c2 = self._get_lo_candidate(self.hw.lo2_def, self._lo2_cand_cache, lo2_t, self.hw.mixer2)\r\n                    if c1 and c2:\r\n                        candidates.append((\"low\", m_sum, c1, c2))\r\n            \r\n            if high_viable:\r\n                m_diff = self._eval_chain_fast(tile, if2_filter, high_side=True, search_mode=search_mode)\r\n                if m_diff > -900.0:\r\n                    lo1_t = if2_filter.center_hz + tile.if1_center_hz\r\n                    lo2_t = tile.rf_center_hz + if2_filter.center_hz\r\n                    c1 = self._get_lo_candidate(self.hw.lo1_def, self._lo1_cand_cache, lo1_t, self.hw.mixer1)\r\n                    c2 = self._get_lo_candidate(self.hw.lo2_def, self._lo2_cand_cache, lo2_t, self.hw.mixer2)\r\n                    if c1 and c2:\r\n                        candidates.append((\"high\", m_diff, c1, c2))\r\n\r\n            if not candidates:\r\n                return -999.0, 99999.0, 0, []\r\n\r\n            candidates.sort(key=lambda x: x[1], reverse=True)\r\n            best_side, best_margin, best_lo1, best_lo2 = candidates[0]\r\n\r\n            # --- Hysteresis Logic ---\r\n            if prev_lo1_freq is not None:\r\n                for side, margin, l1, l2 in candidates:\r\n                    d1 = abs(l1.freq_hz - prev_lo1_freq)\r\n                    d2 = abs(l2.freq_hz - prev_lo2_freq)\r\n                    # If within hysteresis and margin acceptable, prefer sticking\r\n                    if d1 < self.hysteresis_hz and d2 < self.hysteresis_hz:\r\n                        if margin >= self.opt_cutoff + 5.0:\r\n                            best_side, best_margin, best_lo1, best_lo2 = side, margin, l1, l2\r\n                        break\r\n            \r\n            # --- Lock Time Heuristic ---\r\n            lock_ms = 0.0\r\n            did_retune = False\r\n            if prev_lo1_freq is not None:\r\n                d1_mhz = abs(best_lo1.freq_hz - prev_lo1_freq) / 1e6\r\n                d2_mhz = abs(best_lo2.freq_hz - prev_lo2_freq) / 1e6\r\n                t1 = self.hw.lo1_def.lock_base_ms + d1_mhz * self.hw.lo1_def.lock_per_mhz_ms\r\n                t2 = self.hw.lo2_def.lock_base_ms + d2_mhz * self.hw.lo2_def.lock_per_mhz_ms\r\n                lock_ms = max(t1, t2)\r\n                if d1_mhz > 0.0 or d2_mhz > 0.0:\r\n                    did_retune = True\r\n            \r\n            prev_lo1_freq = best_lo1.freq_hz\r\n            prev_lo2_freq = best_lo2.freq_hz\r\n            prev_side = best_side\r\n            \r\n            total_lock_time += lock_ms\r\n            if did_retune: retune_count += 1\r\n            \r\n            if best_margin < worst_margin:\r\n                worst_margin = best_margin\r\n\r\n            # Early Abort\r\n            if stop_if_margin_below is not None and worst_margin < stop_if_margin_below:\r\n                return worst_margin, 99999.0, retune_count, []\r\n\r\n            # Record Entry\r\n            brittleness = 0.0\r\n            if compute_brittleness:\r\n                brittleness = self.calculate_brittleness(tile, if2_filter, (best_side == \"high\"))\r\n\r\n            c1_final = LO_Candidate(\r\n                best_lo1.freq_hz, best_lo1.mode, best_side, \r\n                best_lo1.delivered_power_dbm, best_lo1.pad_db, best_lo1.spectrum\r\n            )\r\n            c2_final = LO_Candidate(\r\n                best_lo2.freq_hz, best_lo2.mode, best_side,\r\n                best_lo2.delivered_power_dbm, best_lo2.pad_db, best_lo2.spectrum\r\n            )\r\n\r\n            entry = TilePolicyEntry(\r\n                tile_id=tile.id,\r\n                if1_center_hz=tile.if1_center_hz,\r\n                bw_hz=tile.bw_hz,\r\n                rf_center_hz=tile.rf_center_hz,\r\n                lo1=c1_final,\r\n                lo2=c2_final,\r\n                spur_margin_db=best_margin,\r\n                brittleness_db_per_step=brittleness,\r\n                lock_time_ms_tile=lock_ms,\r\n                retune_occurred=did_retune,\r\n                side=best_side\r\n            )\r\n            entries.append(entry)\r\n\r\n        entries.sort(key=lambda e: e.tile_id)\r\n        return worst_margin, total_lock_time, retune_count, entries\r\n\r\n    def evaluate_policy(self, if2_filter: FilterModel, search_mode: bool = True):\r\n        \"\"\"\r\n        Entry point used during IF2 search and diagnostics.\r\n        Returns (score, expected_lock_ms).\r\n        \"\"\"\r\n        cutoff = self.cfg.opt_cutoff_db if search_mode else None\r\n\r\n        worst_margin, total_lock, retunes, entries = self.build_policy_for_if2(\r\n            if2_filter,\r\n            search_mode=search_mode,\r\n            compute_brittleness=False,\r\n            stop_if_margin_below=cutoff,\r\n        )\r\n        self.last_retune_count = retunes\r\n\r\n        if not entries and worst_margin <= -900:\r\n            return -999.0, 99999.0\r\n\r\n        # Pass retunes to scoring function now\r\n        score, expected_lock = self._score_policy(if2_filter, worst_margin, entries, retunes)\r\n        return score, expected_lock\r\n\r\n    def _aggregate_expected_lock(self, entries: list[TilePolicyEntry]) -> float:\r\n        if not entries: return 0.0\r\n        n = len(entries)\r\n        lock_by_id = np.zeros(len(self.cfg.tiles), dtype=float)\r\n        for e in entries:\r\n            lock_by_id[e.tile_id] = e.lock_time_ms_tile\r\n\r\n        P = self.cfg.markov_matrix\r\n        pi = self.cfg.markov_stationary\r\n\r\n        # Markov-weighted heuristic\r\n        if P.size > 0 and pi is not None and len(pi) == len(lock_by_id):\r\n            return float(np.dot(pi, lock_by_id))\r\n        else:\r\n            # Fallback: uniform average\r\n            return float(lock_by_id.mean())\r\n\r\n    def _score_policy(self, if2_filter, worst_margin_db, entries, retune_count=0):\r\n        # Hard minimum constraint\r\n        if worst_margin_db < self.cfg.min_margin_db:\r\n            return -1e9, 1e9\r\n\r\n        expected_lock = self._aggregate_expected_lock(entries)\r\n        \r\n        lam_lock = self.cfg.runtime_lock_time_weight\r\n        lam_retune = self.cfg.retune_penalty_weight if self.cfg.prefer_fewer_retunes else 0.0\r\n        \r\n        score = worst_margin_db - (lam_lock * expected_lock) - (lam_retune * float(retune_count))\r\n        return score, expected_lock\r\n\r\n    def calculate_brittleness(self, tile: Tile, if2_filter: FilterModel, high_side: bool):\r\n        base = self._eval_chain_fast(tile, if2_filter, high_side, search_mode=False)\r\n        if base <= -900: return 99.9\r\n        step = self.BRITTLENESS_STEP_HZ \r\n        t_if1 = Tile(tile.id, tile.if1_center_hz + step, tile.bw_hz, tile.rf_center_hz)\r\n        m_if1 = self._eval_chain_fast(t_if1, if2_filter, high_side, search_mode=False)\r\n        t_rf = Tile(tile.id, tile.if1_center_hz, tile.bw_hz, tile.rf_center_hz + step)\r\n        m_rf = self._eval_chain_fast(t_rf, if2_filter, high_side, search_mode=False)\r\n        return max(max(0, base - m_if1), max(0, base - m_rf))\r\n    \r\n    def _eval_chain_approx(self, tile, if2_filter, high_side: bool):\r\n        \"\"\"Approximate margin using dominant-only spur set.\"\"\"\r\n        return self._eval_chain_fast(\r\n            tile, if2_filter, high_side, search_mode=True, dominant_only=True\r\n        )\r\n\r\n    def _eval_chain_fast(self, tile, if2_filter, high_side, search_mode=True, dominant_only=False):\r\n        is_sum_mix = not high_side\r\n        \r\n        if high_side:\r\n            lo1_target = if2_filter.center_hz + tile.if1_center_hz\r\n            lo2_target = tile.rf_center_hz + if2_filter.center_hz\r\n        else:\r\n            lo1_target = if2_filter.center_hz - tile.if1_center_hz\r\n            lo2_target = tile.rf_center_hz - if2_filter.center_hz\r\n\r\n        lo1_freq = self._quantize_lo_freq(self.hw.lo1_def, lo1_target)\r\n        lo2_freq = self._quantize_lo_freq(self.hw.lo2_def, lo2_target)\r\n        \r\n        r1 = self.hw.lo1_def.freq_range\r\n        if not (r1[0] <= lo1_freq <= r1[1]): return -999.0\r\n        r2 = self.hw.lo2_def.freq_range\r\n        if not (r2[0] <= lo2_freq <= r2[1]): return -999.0\r\n            \r\n        valid1, _, p1 = self.hw.get_valid_lo_config(self.hw.lo1_def, lo1_freq, self.hw.mixer1.drive_req)\r\n        if not valid1: return -999.0\r\n        valid2, _, p2 = self.hw.get_valid_lo_config(self.hw.lo2_def, lo2_freq, self.hw.mixer2.drive_req)\r\n        if not valid2: return -999.0\r\n\r\n        if self._early_reject_chain(tile, if2_filter, lo1_freq, lo2_freq, high_side):\r\n            return -999.0\r\n        \r\n        _, recipes1 = self._get_lo_data(\r\n            self.hw.lo1_def, lo1_freq, self.hw.mixer1, p1, search_mode, \r\n            self.max_order_stage1, dominant_only\r\n        )\r\n        _, recipes2 = self._get_lo_data(\r\n            self.hw.lo2_def, lo2_freq, self.hw.mixer2, p2, search_mode, \r\n            self.max_order_stage2, dominant_only\r\n        )\r\n        \r\n        # IF2-Agnostic Stage 1 Spurs (now includes IF1 harmonics)\r\n        raw_stage1 = self._get_stage1_spurs_raw(\r\n            tile, lo1_freq, is_sum_mix, recipes1, search_mode, dominant_only\r\n        )\r\n        \r\n        if raw_stage1.shape[0] > self.stage1_buffer_size:\r\n             new_size = max(self.stage1_buffer_size * 2, raw_stage1.shape[0])\r\n             self.stage1_buffer = np.zeros((new_size, 4), dtype=np.float64)\r\n             self.stage1_buffer_size = new_size\r\n             \r\n        # Apply IF2 Filter & Noise Floor\r\n        # AND explicit desired path suppression based on geometry\r\n        count = 0\r\n        for i in range(raw_stage1.shape[0]):\r\n             f_if2 = raw_stage1[i, 0]\r\n             lvl_pre = raw_stage1[i, 1]\r\n             m1_abs = raw_stage1[i, 2]\r\n             n1_abs = raw_stage1[i, 3]\r\n             \r\n             atten_if2 = get_lut_val(f_if2, self.if2_lut_buffer, self.grid_step)\r\n             lvl_post = lvl_pre - atten_if2\r\n             \r\n             if lvl_post < self.noise_floor: continue\r\n             \r\n             self.stage1_buffer[count, 0] = f_if2\r\n             self.stage1_buffer[count, 1] = lvl_post\r\n             self.stage1_buffer[count, 2] = m1_abs\r\n             self.stage1_buffer[count, 3] = n1_abs\r\n             count += 1\r\n             \r\n        # EXPLICIT DESIRED (1,1) SUPPRESSION\r\n        if self.cfg.enforce_desired_mn11_only:\r\n            if high_side:\r\n                # Diff-Diff desired: |LO1 - IF1|\r\n                f_if2_desired = abs(lo1_freq - tile.if1_center_hz)\r\n            else:\r\n                # Sum-Sum desired: LO1 + IF1\r\n                f_if2_desired = lo1_freq + tile.if1_center_hz\r\n\r\n            # Tolerance check\r\n            tol_if2 = max(100.0, self.grid_step * 1.0)\r\n            \r\n            filtered_count = 0\r\n            for i in range(count):\r\n                f_if2 = self.stage1_buffer[i, 0]\r\n                m1_abs = self.stage1_buffer[i, 2]\r\n                n1_abs = self.stage1_buffer[i, 3]\r\n                \r\n                # Drop only the (1,1) tone at the desired IF2 frequency\r\n                if (m1_abs == 1.0 and n1_abs == 1.0 and abs(f_if2 - f_if2_desired) < tol_if2):\r\n                    continue\r\n                    \r\n                self.stage1_buffer[filtered_count, :] = self.stage1_buffer[i, :]\r\n                filtered_count += 1\r\n            count = filtered_count\r\n\r\n        valid_stage1 = self.stage1_buffer[:count]\r\n        \r\n        margin = compute_stage2_from_intermediates(\r\n            valid_stage1,\r\n            recipes2,\r\n            tile.rf_center_hz,\r\n            if2_filter.center_hz,\r\n            self.rf_lut, self.mask_lut,\r\n            self.grid_step, self.guard_db, self.noise_floor,\r\n            self.rbw_hz,\r\n            self.cross_stage_sum_max,\r\n            self.cfg.max_spur_level_dbc\r\n        )\r\n\r\n        # If the main path already failed hard, just return it\r\n        if margin <= -900.0:\r\n            return margin\r\n\r\n        # Include Mixer-2 IF→RF isolation as a direct RF-port spur\r\n        iso_margin = self._eval_if_iso_mixer2_leakage(if2_filter)\r\n        if iso_margin < margin:\r\n            margin = iso_margin\r\n\r\n        return margin\r\n\r\n    def _early_reject_chain(self, tile, if2_filter, lo1_freq, lo2_freq, high_side: bool) -> bool:\r\n        er_cfg = self.cfg.yaml_data.get('early_reject', {})\r\n        reject_image_if2 = bool(er_cfg.get('image_in_if2_passband', False))\r\n        reject_loft = bool(er_cfg.get('loft_in_if2_or_rf_passbands', False))\r\n        reject_rf_image = bool(er_cfg.get('rf_first_order_image_in_passband', False))\r\n\r\n        if not (reject_image_if2 or reject_loft or reject_rf_image):\r\n            return False\r\n\r\n        if_bw_half = if2_filter.bw_hz * 0.5\r\n        if2_lo = if2_filter.center_hz - if_bw_half\r\n        if2_hi = if2_filter.center_hz + if_bw_half\r\n\r\n        if self.rf_passband_lo_hz > 0.0 or self.rf_passband_hi_hz > 0.0:\r\n            rf_lo = self.rf_passband_lo_hz\r\n            rf_hi = self.rf_passband_hi_hz\r\n        else:\r\n            rf_bw_half = tile.bw_hz * 0.5\r\n            rf_lo = tile.rf_center_hz - rf_bw_half\r\n            rf_hi = tile.rf_center_hz + rf_bw_half\r\n\r\n        if reject_image_if2:\r\n            # Sense-aware IF2 image rejection\r\n            if high_side:\r\n                # Diff-Diff: desired = |LO1 - IF1|, image = LO1 + IF1\r\n                f_if2_image = lo1_freq + tile.if1_center_hz\r\n            else:\r\n                # Sum-Sum: desired = LO1 + IF1, image = |LO1 - IF1|\r\n                f_if2_image = abs(lo1_freq - tile.if1_center_hz)\r\n\r\n            if if2_lo <= f_if2_image <= if2_hi: return True\r\n\r\n        if reject_loft:\r\n            if if2_lo <= lo1_freq <= if2_hi: return True\r\n            if rf_lo <= lo2_freq <= rf_hi: return True\r\n\r\n        if reject_rf_image:\r\n            if high_side: f_img = lo2_freq + if2_filter.center_hz\r\n            else: f_img = abs(lo2_freq - if2_filter.center_hz)\r\n            if rf_lo <= f_img <= rf_hi: return True\r\n\r\n        return False\r\n",
              "encoding": "utf-8",
              "encoding_error": false
            },
            {
              "type": "file",
              "name": "buc_kernels.py",
              "path": "src\\buc\\buc_kernels.py",
              "size": 14833,
              "content_truncated": false,
              "contents": "import numpy as np\r\nfrom numba import jit\r\n\r\n# --- LUT Builders ---\r\n\r\ndef build_dense_lut(x_pts, y_pts, grid_max_hz, grid_step_hz, default_val):\r\n    n_bins = int(grid_max_hz / grid_step_hz) + 2\r\n    lut = np.full(n_bins, default_val, dtype=np.float32)\r\n    \r\n    if len(x_pts) == 0:\r\n        return lut\r\n\r\n    # Pre-process for sloped masks (manual handling if not pure interp)\r\n    # Since x_pts/y_pts here usually come from standard interp for RF filter,\r\n    # this function is mostly for RF S21. \r\n    # Mask construction uses explicit _apply_mask_table logic in SpurEngine.\r\n    \r\n    grid_freqs = np.linspace(0, grid_max_hz, n_bins)\r\n    interpolated = np.interp(grid_freqs, x_pts, y_pts)\r\n    lut[:] = interpolated\r\n    return lut\r\n\r\n# --- JIT Kernels ---\r\n\r\n@jit(nopython=True, fastmath=True)\r\ndef get_lut_val(f_hz, lut, step_hz):\r\n    idx_float = f_hz / step_hz\r\n    idx = int(idx_float)\r\n    if idx < 0: return lut[0]\r\n    if idx >= len(lut) - 1: return lut[-1]\r\n    frac = idx_float - idx\r\n    val = lut[idx] * (1.0 - frac) + lut[idx+1] * frac\r\n    return val\r\n\r\n@jit(nopython=True, fastmath=True)\r\ndef fill_symmetric_filter_lut(lut, center_hz, bw_hz, il_db, rolloff, stop_floor, step_hz):\r\n    \"\"\"\r\n    Symmetric power-law IF2 model.\r\n    \"\"\"\r\n    n_bins = len(lut)\r\n    hbw = bw_hz / 2.0\r\n    start_f = center_hz - bw_hz * 5.0\r\n    stop_f = center_hz + bw_hz * 5.0\r\n    idx_start = max(0, int(start_f / step_hz))\r\n    idx_stop = min(n_bins, int(stop_f / step_hz))\r\n\r\n    if il_db < 0.0:\r\n        il_db = 0.0\r\n    if stop_floor < il_db:\r\n        stop_floor = il_db\r\n\r\n    for i in range(idx_start, idx_stop):\r\n        f = i * step_hz\r\n        delta = abs(f - center_hz)\r\n        if delta <= hbw:\r\n            lut[i] = il_db\r\n        else:\r\n            ratio = delta / hbw\r\n            if ratio < 1.0:\r\n                ratio = 1.0\r\n            atten = il_db + rolloff * np.log10(ratio)\r\n            if atten > stop_floor:\r\n                atten = stop_floor\r\n            if atten < il_db:\r\n                atten = il_db\r\n            lut[i] = atten\r\n\r\n@jit(nopython=True, fastmath=True)\r\ndef fill_scaled_s2p_lut(lut, center_hz, bw_hz, proto_x, proto_y, stop_floor, step_hz):\r\n    \"\"\"\r\n    Scaled S2P prototype.\r\n    \"\"\"\r\n    n_bins = len(lut)\r\n    min_x, max_x = proto_x[0], proto_x[-1]\r\n    min_freq = min_x * bw_hz + center_hz\r\n    max_freq = max_x * bw_hz + center_hz\r\n    idx_start = max(0, int(min_freq / step_hz))\r\n    idx_stop = min(n_bins, int(max_freq / step_hz))\r\n\r\n    if stop_floor < 0.0:\r\n        stop_floor = -stop_floor\r\n\r\n    for i in range(idx_start, idx_stop):\r\n        f_grid = i * step_hz\r\n        x_req = (f_grid - center_hz) / bw_hz\r\n        val = np.interp(x_req, proto_x, proto_y)\r\n        if val > stop_floor:\r\n            val = stop_floor\r\n        if val < 0.0:\r\n            val = 0.0\r\n        lut[i] = val\r\n\r\n# --- CORE SPUR PHYSICS ---\r\n\r\n@jit(nopython=True, fastmath=True)\r\ndef precompute_mixing_recipes(lo_comps, mxr_table, search_mode, \r\n                              drive_delta_db, scale_slope, scale_cap,\r\n                              max_order,\r\n                              include_lo_feedthrough=False,\r\n                              lo_feedthrough_rej_db=0.0,\r\n                              dominant_only=False):\r\n    \"\"\"\r\n    Flattens LO Spectrum * Mixer Table into a single list of recipes.\r\n\r\n    IMPORTANT FIXES:\r\n    - No longer enumerate ±LO harmonics separately:\r\n        eff_lo is always +m * f_LO.\r\n    - For n > 0, enumerate ±n on the IF side (sum/diff products),\r\n      EXCEPT for the special \"pure IF\" families (m = 0, n > 0), where\r\n      |m f_LO ± n f_IF| collapses to the same |n| f_IF.  In that case\r\n      emit only a single signed_n = +n recipe.\r\n    - For n == 0, emit a single recipe (no sum/diff).\r\n\r\n    This removes:\r\n      * the old 4× duplication from (+LO, ±n) vs (−LO, ±n), and\r\n      * the residual 2× duplication for (m = 0, ±n) that collapses\r\n        to the same physical “pure IF” spur under abs().\r\n    \"\"\"\r\n    n_lo = lo_comps.shape[0]\r\n    n_mx = mxr_table.shape[0]\r\n    max_k = 10 if search_mode else 99\r\n\r\n    if search_mode:\r\n        active_max_order = max_order if max_order < 10 else 10\r\n    else:\r\n        active_max_order = max_order\r\n\r\n    # LO drive scaling\r\n    correction = drive_delta_db * scale_slope\r\n    if correction > scale_cap:\r\n        correction = scale_cap\r\n    elif correction < -scale_cap:\r\n        correction = -scale_cap\r\n\r\n    # Conservative size estimate (still safe even though we generate fewer)\r\n    size_est = n_lo * n_mx * 4 + (1 if include_lo_feedthrough else 0)\r\n    recipes = np.zeros((size_est, 6), dtype=np.float64)\r\n    count = 0\r\n\r\n    # Optional explicit LO feedthrough spur (separate from spur table entries)\r\n    if include_lo_feedthrough:\r\n        f_lo_main = lo_comps[0, 0]\r\n        lvl_lo = lo_comps[0, 1] + lo_feedthrough_rej_db\r\n        recipes[count, 0] = f_lo_main     # eff_lo\r\n        recipes[count, 1] = 0.0           # signed_n\r\n        recipes[count, 2] = lvl_lo        # gain\r\n        recipes[count, 3] = 1.0           # m_abs\r\n        recipes[count, 4] = 0.0           # n_abs\r\n        recipes[count, 5] = 0.0           # is_desired (unused)\r\n        count += 1\r\n\r\n    # Phase-1 assumption: desired family is (1,1); the engine later\r\n    # suppresses the desired path explicitly by geometry, so the\r\n    # is_desired flag here is informational only.\r\n    desired_m = 1\r\n    desired_n = 1\r\n\r\n    for k in range(n_lo):\r\n        if search_mode and k > max_k:\r\n            break\r\n\r\n        f_lo_c = lo_comps[k, 0]\r\n        p_lo_c = lo_comps[k, 1]\r\n\r\n        is_main_lo = (k == 0)\r\n\r\n        for i in range(n_mx):\r\n            m = int(mxr_table[i, 0])\r\n            n = int(mxr_table[i, 1])\r\n            base_rej = mxr_table[i, 2]\r\n\r\n            if m > active_max_order or n > active_max_order:\r\n                continue\r\n\r\n            # Dominant spur pruning\r\n            if dominant_only:\r\n                is_dom = False\r\n                if ((m == 1 and n == 1) or\r\n                    (m == 1 and n == 2) or\r\n                    (m == 2 and n == 1) or\r\n                    (m == 2 and n == 2) or\r\n                    (m == 3 and n == 1)):\r\n                    is_dom = True\r\n                if not is_dom:\r\n                    continue\r\n\r\n            scaled_rej = base_rej - correction\r\n            lvl_fixed = p_lo_c + scaled_rej\r\n\r\n            # n == 0 : pure LO term → one recipe only (no ±n)\r\n            if n == 0:\r\n                if count >= size_est:\r\n                    break\r\n\r\n                eff_lo = m * f_lo_c  # always +m * f_LO\r\n\r\n                recipes[count, 0] = eff_lo\r\n                recipes[count, 1] = 0.0               # signed_n\r\n                recipes[count, 2] = lvl_fixed\r\n                recipes[count, 3] = float(m)\r\n                recipes[count, 4] = float(n)\r\n                # is_desired flag is informational only and currently unused\r\n                recipes[count, 5] = 1.0 if (is_main_lo and\r\n                                            m == desired_m and\r\n                                            n == desired_n) else 0.0\r\n                count += 1\r\n                continue\r\n\r\n            # n > 0 : sum/diff products; LO sign is not enumerated\r\n            eff_lo = m * f_lo_c  # +m * f_LO\r\n\r\n            if m == 0:\r\n                # Special-case pure IF families (m = 0, n > 0):\r\n                # |0 * f_LO ± n * f_IF| → |n| f_IF, so ±n are the same\r\n                # physical spur under abs(). Emit only +n.\r\n                if count >= size_est:\r\n                    break\r\n\r\n                signed_n = float(n)\r\n                # This can never be the desired (1,1) family, so is_des = 0.0\r\n                is_des = 0.0\r\n\r\n                recipes[count, 0] = eff_lo\r\n                recipes[count, 1] = signed_n\r\n                recipes[count, 2] = lvl_fixed\r\n                recipes[count, 3] = float(m)\r\n                recipes[count, 4] = float(n)\r\n                recipes[count, 5] = is_des\r\n                count += 1\r\n            else:\r\n                # General case: keep ±n (sum/diff) for m != 0\r\n                for s_in in (-1, 1):\r\n                    if count >= size_est:\r\n                        break\r\n\r\n                    signed_n = s_in * n\r\n\r\n                    # Informational desired-flag only; engine does not rely on this\r\n                    is_des = 1.0 if (is_main_lo and\r\n                                     m == desired_m and\r\n                                     n == desired_n) else 0.0\r\n\r\n                    recipes[count, 0] = eff_lo\r\n                    recipes[count, 1] = signed_n\r\n                    recipes[count, 2] = lvl_fixed\r\n                    recipes[count, 3] = float(m)\r\n                    recipes[count, 4] = float(n)\r\n                    recipes[count, 5] = is_des\r\n                    count += 1\r\n\r\n    return recipes[:count]\r\n\r\n@jit(nopython=True, fastmath=True)\r\ndef compute_stage1_spurs_no_if2(\r\n    stage1_recipes,   # [eff_lo, signed_n, gain, m_abs, n_abs, is_desired]\r\n    if1_freq,\r\n    result_buffer     # shape (N, 4): [f_if2, lvl_pre_if2, m1_abs, n1_abs]\r\n):\r\n    \"\"\"\r\n    IF2-agnostic Stage-1 spur generation.\r\n    Computes f_if2 = | eff_lo + signed_n * if1_freq |\r\n    \r\n    Purely algebraic; does NOT attempt to identify or suppress desired paths.\r\n    Desired path suppression is handled by the caller (SpurEngine) based on\r\n    exact geometric constraints.\r\n    \"\"\"\r\n    count = 0\r\n    max_buffer = result_buffer.shape[0]\r\n    n_recipes = stage1_recipes.shape[0]\r\n\r\n    for i in range(n_recipes):\r\n        eff_lo = stage1_recipes[i, 0]\r\n        signed_n = stage1_recipes[i, 1]\r\n        gain = stage1_recipes[i, 2]\r\n        m_abs = stage1_recipes[i, 3]\r\n        n_abs = stage1_recipes[i, 4]\r\n        \r\n        # Algebraic mixing product\r\n        f_if2 = abs(eff_lo + signed_n * if1_freq)\r\n\r\n        if count >= max_buffer:\r\n            return -count  # overflow\r\n\r\n        result_buffer[count, 0] = f_if2\r\n        result_buffer[count, 1] = gain\r\n        result_buffer[count, 2] = m_abs\r\n        result_buffer[count, 3] = n_abs\r\n        count += 1\r\n\r\n    return count\r\n\r\n@jit(nopython=True, fastmath=True)\r\ndef compute_stage2_from_intermediates(\r\n    stage1_spurs,       # [f_if2, lvl_after_if2, m1_abs, n1_abs]\r\n    stage2_recipes,     # [eff_lo, signed_n, gain, m2_abs, n2_abs, is_desired]\r\n    rf_freq_desired,\r\n    f_if2_desired,\r\n    rf_lut,\r\n    mask_lut,\r\n    grid_step,\r\n    guard_db,\r\n    noise_floor_dbc,\r\n    rbw_hz,\r\n    cross_stage_sum_max,\r\n    max_spur_dbc        # Clamp for spur levels\r\n):\r\n    \"\"\"\r\n    Stage-2 evaluation with explicit clamp and cross-stage check.\r\n    Leakage math updated to be physically additive (dB+dB).\r\n    \"\"\"\r\n    min_margin = 999.0\r\n    n_recipes = stage2_recipes.shape[0]\r\n    n_s1 = stage1_spurs.shape[0]\r\n    n_mask = mask_lut.shape[0]\r\n    \r\n    pow_bins = np.zeros(n_mask)\r\n    bins_per_rbw = int(rbw_hz / grid_step)\r\n    if bins_per_rbw < 1:\r\n        bins_per_rbw = 1\r\n    \r\n    # --- 1. Direct IF2 -> RF spurs ---\r\n    # Phase-1: Desired path is fixed to (1,1)\r\n    m1_abs_direct = 1.0\r\n    n1_abs_direct = 1.0\r\n\r\n    for i in range(n_recipes):\r\n        eff_lo = stage2_recipes[i, 0]\r\n        signed_n = stage2_recipes[i, 1]\r\n        gain = stage2_recipes[i, 2]\r\n        m2_abs = stage2_recipes[i, 3]\r\n        n2_abs = stage2_recipes[i, 4]\r\n        \r\n        total_order = m1_abs_direct + n1_abs_direct + m2_abs + n2_abs\r\n        if total_order > cross_stage_sum_max:\r\n            continue\r\n            \r\n        f_spur_rf = abs(eff_lo + signed_n * f_if2_desired)\r\n        \r\n        # Skip main carrier\r\n        tol = rf_freq_desired * 1e-6\r\n        if tol < 100.0: tol = 100.0\r\n        if abs(f_spur_rf - rf_freq_desired) < tol: \r\n            continue\r\n\r\n        idx = int(f_spur_rf / grid_step)\r\n        if idx < 0 or idx >= n_mask: continue\r\n\r\n        atten_rf = get_lut_val(f_spur_rf, rf_lut, grid_step)\r\n        final_lvl = gain - atten_rf\r\n        \r\n        if final_lvl < noise_floor_dbc: continue\r\n        \r\n        limit = mask_lut[idx]\r\n        margin_line = limit - final_lvl - guard_db\r\n        if margin_line < min_margin: min_margin = margin_line\r\n\r\n        p_lin = 10.0 ** (final_lvl / 10.0)\r\n        pow_bins[idx] += p_lin\r\n\r\n    # --- 2. Stage-1 leakage spurs -> Stage-2 ---\r\n    for i_s1 in range(n_s1):\r\n        f_input = stage1_spurs[i_s1, 0]\r\n        l_input = stage1_spurs[i_s1, 1] # dBc at IF2\r\n        m1_abs = stage1_spurs[i_s1, 2]\r\n        n1_abs = stage1_spurs[i_s1, 3]\r\n        \r\n        # Configurable clamp: only active if max_spur_dbc is negative (e.g. -10)\r\n        # If max_spur_dbc is 0.0, no clamp is applied.\r\n        if max_spur_dbc < 0.0 and l_input > max_spur_dbc:\r\n            l_input = max_spur_dbc\r\n\r\n        for i in range(n_recipes):\r\n            eff_lo = stage2_recipes[i, 0]\r\n            signed_n = stage2_recipes[i, 1]\r\n            gain = stage2_recipes[i, 2]\r\n            m2_abs = stage2_recipes[i, 3]\r\n            n2_abs = stage2_recipes[i, 4]\r\n            \r\n            total_order = m1_abs + n1_abs + m2_abs + n2_abs\r\n            if total_order > cross_stage_sum_max:\r\n                continue\r\n            \r\n            f_final_rf = abs(eff_lo + signed_n * f_input)\r\n            \r\n            idx = int(f_final_rf / grid_step)\r\n            if idx < 0 or idx >= n_mask: continue\r\n\r\n            # Leakage model: Stage-1 level (dB) + Stage-2 gain (dB)\r\n            lvl_rf = l_input + gain\r\n            \r\n            atten_rf = get_lut_val(f_final_rf, rf_lut, grid_step)\r\n            final_lvl = lvl_rf - atten_rf\r\n            \r\n            if final_lvl < noise_floor_dbc: continue\r\n            \r\n            limit = mask_lut[idx]\r\n            margin_line = limit - final_lvl - guard_db\r\n            if margin_line < min_margin: min_margin = margin_line\r\n\r\n            p_lin = 10.0 ** (final_lvl / 10.0)\r\n            pow_bins[idx] += p_lin\r\n\r\n    # --- 3. RBW aggregation ---\r\n    if bins_per_rbw == 1:\r\n        for idx in range(n_mask):\r\n            if pow_bins[idx] <= 0.0:\r\n                continue\r\n            lvl_db = 10.0 * np.log10(pow_bins[idx])\r\n            limit = mask_lut[idx]\r\n            margin_bin = limit - lvl_db - guard_db\r\n            if margin_bin < min_margin:\r\n                min_margin = margin_bin\r\n    else:\r\n        window_power = 0.0\r\n        for idx in range(n_mask):\r\n            window_power += pow_bins[idx]\r\n            if idx >= bins_per_rbw:\r\n                window_power -= pow_bins[idx - bins_per_rbw]\r\n            if window_power <= 0.0:\r\n                continue\r\n            lvl_db = 10.0 * np.log10(window_power)\r\n            limit = mask_lut[idx]\r\n            margin_bin = limit - lvl_db - guard_db\r\n            if margin_bin < min_margin:\r\n                min_margin = margin_bin\r\n\r\n    return min_margin",
              "encoding": "utf-8",
              "encoding_error": false
            },
            {
              "type": "file",
              "name": "buc_markov.py",
              "path": "src\\buc\\buc_markov.py",
              "size": 1403,
              "content_truncated": false,
              "contents": "import numpy as np\r\nimport pandas as pd\r\nimport json\r\n\r\ndef markov_lock_summary(df_policy: pd.DataFrame, \r\n                        markov_matrix: np.ndarray, \r\n                        out_path: str = \"markov_lock_summary.json\"):\r\n    \"\"\"\r\n    Diagnostic-only Markov-weighted lock-time summary.\r\n    \"\"\"\r\n    if markov_matrix.size == 0:\r\n        return\r\n\r\n    df_policy = df_policy.sort_values(\"tile_id\")\r\n    tile_ids = df_policy[\"tile_id\"].to_numpy()\r\n    lock_times = df_policy[\"lock_time_ms_tile\"].to_numpy()\r\n\r\n    n = len(tile_ids)\r\n    if markov_matrix.shape != (n, n):\r\n        print(\"Markov matrix shape mismatch; skipping Markov summary.\")\r\n        return\r\n\r\n    # Stationary distribution via power iteration\r\n    dist = np.ones(n) / n\r\n    for _ in range(1000):\r\n        dist_new = dist @ markov_matrix\r\n        if np.max(np.abs(dist_new - dist)) < 1e-9:\r\n            dist = dist_new\r\n            break\r\n        dist = dist_new\r\n\r\n    expected_lock_time = float(np.dot(dist, lock_times))\r\n\r\n    summary = {\r\n        \"num_tiles\": int(n),\r\n        \"tile_ids\": tile_ids.tolist(),\r\n        \"lock_time_ms_tile\": lock_times.tolist(),\r\n        \"stationary_distribution\": dist.tolist(),\r\n        \"expected_lock_time_ms_stationary\": expected_lock_time,\r\n    }\r\n\r\n    with open(out_path, \"w\") as f:\r\n        json.dump(summary, f, indent=2)\r\n\r\n    print(f\"Markov lock-time summary written to {out_path}\")",
              "encoding": "utf-8",
              "encoding_error": false
            },
            {
              "type": "file",
              "name": "buc_models.py",
              "path": "src\\buc\\buc_models.py",
              "size": 10330,
              "content_truncated": false,
              "contents": "import numpy as np\r\nfrom .buc_structures import MixerModel, SynthesizerModel\r\n\r\nclass HardwareStack:\r\n    def __init__(self, cfg, stack_def):\r\n        self.cfg = cfg\r\n        self.name = stack_def['name']\r\n        self.mixer1 = self._find_mixer(cfg, stack_def['mixer1'])\r\n        self.mixer2 = self._find_mixer(cfg, stack_def['mixer2'])\r\n        self.lo1_def = self._find_lo(cfg, stack_def['lo1'], \"lo1\")\r\n        self.lo2_def = self._find_lo(cfg, stack_def['lo2'], \"lo2\")\r\n        self.rf_bpf_id = stack_def.get('rf_bpf_file', 'rf_bpf_synthetic')\r\n    \r\n    def _find_mixer(self, cfg, name):\r\n        for m in cfg.yaml_data['mixers']:\r\n            if m['name'] == name:\r\n                derate = m.get('drive_derate', {})\r\n                nom_dbm = derate.get('nominal_dbm', 13.0)\r\n                \r\n                fam_scale = m.get('lo_family_scaling', {})\r\n                slope = fam_scale.get('default_slope_db_per_db', 1.0)\r\n                cap = fam_scale.get('cap_db', 12.0)\r\n\r\n                include_iso = m.get('include_isolation_spurs', True)\r\n\r\n                return MixerModel(\r\n                    name=m['name'],\r\n                    lo_range=tuple(m['lo_range_hz']),\r\n                    drive_req=(m['required_lo_drive_dbm']['min'], m['required_lo_drive_dbm']['max']),\r\n                    isolation=m.get('isolation', {}),\r\n                    spur_table_raw=[(x[0], x[1], x[2]) for x in m['spur_list']],\r\n                    nom_drive_dbm=nom_dbm,\r\n                    scaling_slope=slope,\r\n                    scaling_cap=cap,\r\n                    include_isolation_spurs=include_iso\r\n                )\r\n        raise ValueError(f\"Mixer {name} not found\")\r\n    \r\n\r\n    def _find_lo(self, cfg, name, role):\r\n        for l in cfg.yaml_data['los']:\r\n            if l['name'] != name:\r\n                continue\r\n\r\n            dist_cfg = l.get('distribution', {})\r\n            dist_loss = float(dist_cfg.get('path_losses_db', {}).get(role, 3.0))\r\n            pads = [float(p) for p in dist_cfg.get('pad_options_db', [0, 3, 6])]\r\n\r\n            # Output power vs frequency\r\n            p_freqs = np.array([1e6, 40e9], dtype=float)\r\n            p_vals = np.array([float(l.get('output_power_dbm', 0.0))] * 2, dtype=float)\r\n\r\n            if 'output_power_model' in l and 'table' in l['output_power_model']:\r\n                tbl = l['output_power_model']['table']\r\n                p_freqs = np.array([float(f) for f in tbl['freq_hz']], dtype=float)\r\n                p_vals = np.array([float(v) for v in tbl['p_out_dbm']], dtype=float)\r\n\r\n            modes = l.get('modes', [])\r\n            harmonics = []\r\n            pfd_spurs = []\r\n            # defaults\r\n            pfd_hz = 100e6\r\n            pfd_min, pfd_max = 0.0, 0.0\r\n            frac_en = False\r\n            frac_lvl = -60.0\r\n            frac_slope = 10.0\r\n\r\n            lock_base = 0.4\r\n            lock_slope = 0.002\r\n\r\n            mode_name = \"fracN\"\r\n            vco_divs = [1]\r\n            pfd_divs = [1]\r\n            int_frac_penalty = 0.0\r\n\r\n            if modes:\r\n                m = modes[0]  # first mode only for now\r\n                mode_name = m.get('name', 'fracN')\r\n                vco_divs = [int(x) for x in m.get('vco_dividers', [1])]\r\n                pfd_divs = [int(x) for x in m.get('pfd_dividers', [1])]\r\n\r\n                harmonics = []\r\n                for h in m.get('harmonics', []):\r\n                    # ensure numeric\r\n                    harmonics.append({\r\n                        'k': int(h.get('k', 1)),\r\n                        'rel_dBc': float(h.get('rel_dBc', -60.0)),\r\n                    })\r\n\r\n                pfd_cfg = m.get('pfd_spurs_at_output', {})\r\n                if 'families' in pfd_cfg:\r\n                    for fam in pfd_cfg['families']:\r\n                        if 'components' in fam:\r\n                            for comp in fam['components']:\r\n                                pfd_spurs.append({\r\n                                    'k': int(comp.get('k', 1)),\r\n                                    'base_rel_dBc': float(comp.get('base_rel_dBc', -60.0)),\r\n                                    'rolloff_dB_per_dec': float(comp.get('rolloff_dB_per_dec', 0.0)),\r\n                                })\r\n\r\n                if 'pfd_hz_range' in m:\r\n                    pfd_min = float(m['pfd_hz_range'][0])\r\n                    pfd_max = float(m['pfd_hz_range'][1])\r\n                    pfd_hz = (pfd_min + pfd_max) / 2.0\r\n\r\n                fb = m.get('frac_boundary_spurs', {})\r\n                frac_en = bool(fb.get('enabled', False))\r\n                frac_lvl = float(fb.get('amplitude_at_eps0p5_rel_dBc', -58.0))\r\n                frac_slope = float(fb.get('rolloff_slope_db_per_dec', 10.0))\r\n\r\n                lt = m.get('lock_time_model', {})\r\n                lock_base = float(lt.get('base_ms', 0.4))\r\n                lock_slope = float(lt.get('per_mhz_ms', 0.002))\r\n                penalties = lt.get('mode_penalties_ms', {})\r\n                int_frac_penalty = float(penalties.get('int_to_frac', 0.0))\r\n\r\n            div_spec_raw = l.get('divider_spectrum', {})\r\n            # normalize divider_spectrum to use floats\r\n            div_spec = {}\r\n            for key, val in div_spec_raw.items():\r\n                try:\r\n                    div_spec[key] = {\r\n                        'harm_delta_dBc': float(val.get('harm_delta_dBc', 0.0))\r\n                    }\r\n                except Exception:\r\n                    # if malformed, just skip this entry\r\n                    continue\r\n\r\n            return SynthesizerModel(\r\n                name=l['name'],\r\n                freq_range=(float(l['freq_range_hz'][0]), float(l['freq_range_hz'][1])),\r\n                step_hz=float(l.get('step_hz', 100e3)),\r\n                power_freqs=p_freqs,\r\n                power_dbm=p_vals,\r\n                dist_loss_db=dist_loss,\r\n                pad_options=pads,\r\n                harmonics=harmonics,\r\n                pfd_freq_hz=pfd_hz,\r\n                pfd_spurs=pfd_spurs,\r\n                frac_boundary_enabled=frac_en,\r\n                frac_boundary_lvl=frac_lvl,\r\n                frac_boundary_slope=frac_slope,\r\n                pfd_min_hz=pfd_min,\r\n                pfd_max_hz=pfd_max,\r\n                lock_base_ms=lock_base,\r\n                lock_per_mhz_ms=lock_slope,\r\n                vco_dividers=vco_divs,\r\n                pfd_dividers=pfd_divs,\r\n                mode_name=mode_name,\r\n                int_frac_switch_penalty_ms=int_frac_penalty,\r\n                divider_spectrum=div_spec,\r\n            )\r\n        raise ValueError(f\"LO {name} not found\")\r\n\r\n    def get_valid_lo_config(self, lo_model: SynthesizerModel, target_freq, mixer_drive_req):\r\n        if target_freq < lo_model.freq_range[0] or target_freq > lo_model.freq_range[1]:\r\n            return False, 0, 0\r\n\r\n        proj = getattr(self, \"cfg\", None)\r\n        if proj is not None and lo_model.pfd_min_hz > 0.0 and lo_model.pfd_max_hz > 0.0:\r\n            ref = float(proj.yaml_data.get('project', {}).get('reference_10mhz_hz', 0.0))\r\n            if ref > 0.0:\r\n                f_pfd_min = ref / 16.0\r\n                f_pfd_max = ref\r\n                if lo_model.pfd_max_hz < f_pfd_min or lo_model.pfd_min_hz > f_pfd_max:\r\n                    if not hasattr(self, \"_pfd_warned\"):\r\n                        self._pfd_warned = set()\r\n                    key = lo_model.name\r\n                    if key not in self._pfd_warned:\r\n                        print(f\"Warning: LO '{lo_model.name}' pfd_hz_range \"\r\n                              f\"{lo_model.pfd_min_hz/1e6:.1f}–{lo_model.pfd_max_hz/1e6:.1f} MHz \"\r\n                              f\"does not overlap ref-based window {f_pfd_min/1e6:.3f}–{f_pfd_max/1e6:.3f} MHz.\")\r\n                        self._pfd_warned.add(key)\r\n\r\n        p_source = np.interp(target_freq, lo_model.power_freqs, lo_model.power_dbm)\r\n        \r\n        valid_pads = []\r\n        for pad in lo_model.pad_options:\r\n            p_del = p_source - lo_model.dist_loss_db - pad\r\n            if mixer_drive_req[0] <= p_del <= mixer_drive_req[1]:\r\n                valid_pads.append((pad, p_del))\r\n        \r\n        if not valid_pads:\r\n            return False, 0, 0\r\n        \r\n        valid_pads.sort(key=lambda x: (x[0], x[1]), reverse=True) \r\n        best = valid_pads[0]\r\n        return True, best[0], best[1]\r\n\r\n    def generate_lo_spectrum(self, lo_model: SynthesizerModel, f_center: float, f_pfd: float = None):\r\n        \"\"\"\r\n        Generates 2D numpy array [[freq, rel_dBc], ...].\r\n        Now accepts explicit f_pfd and applies divider spectrum deltas.\r\n        \"\"\"\r\n        if f_pfd is None:\r\n            f_pfd = lo_model.pfd_freq_hz\r\n\r\n        comps = []\r\n        # Main LO Tone\r\n        comps.append([f_center, 0.0])\r\n        \r\n        # Harmonics with divider-dependent adjustment\r\n        # Phase-1 assumption: operating effectively at /1 for now, \r\n        # but scaffolding allows future variable dividers.\r\n        div_key = \"/1\" \r\n        harm_delta = 0.0\r\n        if lo_model.divider_spectrum:\r\n            harm_delta = float(lo_model.divider_spectrum.get(div_key, {}).get(\"harm_delta_dBc\", 0.0))\r\n        \r\n        for h in lo_model.harmonics:\r\n            lvl = h['rel_dBc'] + harm_delta\r\n            comps.append([f_center * h['k'], lvl])\r\n            \r\n        # PFD Spurs\r\n        # Note: detailed rolloff_dB_per_dec is parsed but currently ignored in Phase-1\r\n        for p in lo_model.pfd_spurs:\r\n            offset = p['k'] * f_pfd\r\n            base_lvl = p.get('base_rel_dBc', -60.0)\r\n            lvl = base_lvl\r\n            comps.append([f_center + offset, lvl])\r\n            comps.append([f_center - offset, lvl])\r\n\r\n        # Fractional boundary spurs\r\n        if lo_model.frac_boundary_enabled and f_pfd > 0:\r\n            N_float = f_center / f_pfd\r\n            N_int = round(N_float)\r\n            epsilon = abs(N_float - N_int)\r\n            \r\n            if epsilon > 1e-6:\r\n                f_boundary = N_int * f_pfd\r\n                if epsilon > 0.5: epsilon = 1.0 - epsilon \r\n                \r\n                delta_dec = np.log10(0.5 / epsilon)\r\n                lvl = lo_model.frac_boundary_lvl + lo_model.frac_boundary_slope * delta_dec\r\n                \r\n                lvl = min(0, lvl)\r\n                comps.append([f_boundary, lvl])\r\n\r\n        return np.array(comps, dtype=np.float64)",
              "encoding": "utf-8",
              "encoding_error": false
            },
            {
              "type": "file",
              "name": "buc_structures.py",
              "path": "src\\buc\\buc_structures.py",
              "size": 16864,
              "content_truncated": false,
              "contents": "import yaml\r\nimport numpy as np\r\nimport os\r\nfrom dataclasses import dataclass, field\r\nfrom typing import List, Dict, Tuple, Optional\r\n\r\n@dataclass\r\nclass Tile:\r\n    id: int\r\n    if1_center_hz: float\r\n    bw_hz: float\r\n    rf_center_hz: float\r\n\r\n@dataclass\r\nclass LO_Candidate:\r\n    freq_hz: float\r\n    mode: str \r\n    side: str \r\n    delivered_power_dbm: float\r\n    pad_db: float\r\n    spectrum: np.ndarray \r\n\r\n@dataclass\r\nclass TilePolicyEntry:\r\n    tile_id: int\r\n    if1_center_hz: float\r\n    bw_hz: float\r\n    rf_center_hz: float\r\n    \r\n    lo1: LO_Candidate\r\n    lo2: LO_Candidate\r\n    \r\n    spur_margin_db: float\r\n    brittleness_db_per_step: float\r\n    \r\n    lock_time_ms_tile: float\r\n    retune_occurred: bool\r\n    side: str  # \"low\" or \"high\"\r\n\r\n@dataclass\r\nclass MixerModel:\r\n    name: str\r\n    lo_range: Tuple[float, float]\r\n    drive_req: Tuple[float, float]\r\n    isolation: Dict[str, float]\r\n    spur_table_raw: List[Tuple[int, int, float]]\r\n    # scaling parameters (TDS 5.2)\r\n    nom_drive_dbm: float = 13.0\r\n    scaling_slope: float = 1.0\r\n    scaling_cap: float = 12.0\r\n    \r\n    include_isolation_spurs: bool = True\r\n    \r\n    spur_table_np: np.ndarray = field(init=False)\r\n\r\n    def __post_init__(self):\r\n        arr = np.array(self.spur_table_raw, dtype=np.float64)\r\n        if arr.size == 0:\r\n            self.spur_table_np = arr\r\n            return\r\n\r\n        # PHASE 1 UPDATE: Do NOT strip (1,1) entries. \r\n        # The kernel will identify desired vs spur based on config.\r\n        self.spur_table_np = arr\r\n        \r\n    def lo_feedthrough_rej_db(self) -> float:\r\n        return float(self.isolation.get(\"lo_to_rf_db\", -40.0))\r\n\r\n    def if_feedthrough_rej_db(self) -> float:\r\n        return float(self.isolation.get(\"if_to_rf_db\", -60.0))\r\n\r\n@dataclass\r\nclass SynthesizerModel:\r\n    name: str\r\n    freq_range: Tuple[float, float]\r\n    step_hz: float\r\n    power_freqs: np.ndarray\r\n    power_dbm: np.ndarray\r\n    dist_loss_db: float\r\n    pad_options: List[float]\r\n    harmonics: List[Dict] \r\n    pfd_freq_hz: float\r\n    pfd_spurs: List[Dict]\r\n    frac_boundary_enabled: bool\r\n    frac_boundary_lvl: float\r\n    frac_boundary_slope: float\r\n    # Explicit PFD range (Hz)\r\n    pfd_min_hz: float = 0.0\r\n    pfd_max_hz: float = 0.0\r\n    # Lock Time Params\r\n    lock_base_ms: float = 0.4\r\n    lock_per_mhz_ms: float = 0.002\r\n    \r\n    # Scaffolding fields\r\n    vco_dividers: List[int] = field(default_factory=lambda: [1])\r\n    pfd_dividers: List[int] = field(default_factory=lambda: [1])\r\n    mode_name: str = \"fracN\"\r\n    int_frac_switch_penalty_ms: float = 0.0\r\n    \r\n    divider_spectrum: Dict = field(default_factory=dict)\r\n\r\n@dataclass\r\nclass FilterModel:\r\n    center_hz: float = 0.0\r\n    bw_hz: float = 0.0\r\n    model_type: int = 0  # 0=Symmetric, 1=S2P\r\n    passband_il: float = 1.0        # +ve insertion loss [dB]\r\n    rolloff: float = 40.0           # dB/dec\r\n    stop_floor: float = 80.0        # +ve attenuation [dB]\r\n    proto_idx: int = -1 \r\n\r\n@dataclass\r\nclass GlobalConfig:\r\n    \"\"\"\r\n    Global configuration and precomputed grids.\r\n    \"\"\"\r\n    yaml_data: dict\r\n    tiles: List[Tile] = field(default_factory=list)\r\n    \r\n    grid_max_freq_hz: float = 65e9\r\n    grid_step_hz: float = 500e3 \r\n    \r\n    # Plumbing\r\n    if2_grid_step_hz: float = 500e3\r\n    rf_grid_step_hz: float = 500e3\r\n    mask_grid_step_hz: float = 500e3\r\n\r\n    # Targets & Cutoffs\r\n    min_margin_db: float = 0.0\r\n    opt_cutoff_db: float = -20.0\r\n    noise_floor_dbc: float = -100.0\r\n    \r\n    # Physics Knobs\r\n    max_spur_level_dbc: float = 0.0\r\n    rf_passband_max_atten_db: float = 5.0\r\n    \r\n    # RBW & order & hysteresis\r\n    rbw_hz: float = 500e3\r\n    m1_max_order: int = 7\r\n    m2_max_order: int = 7\r\n    hysteresis_hz: float = 50e6\r\n    cross_stage_sum_max: int = 12\r\n    \r\n    # Desired Path Config\r\n    enforce_desired_mn11_only: bool = True\r\n    desired_stage1_mn: Tuple[int, int] = (1, 1)\r\n    desired_stage2_mn: Tuple[int, int] = (1, 1)\r\n\r\n    rf_filter_raw_freqs: np.ndarray = field(default_factory=lambda: np.array([]))\r\n    rf_filter_raw_atten: np.ndarray = field(default_factory=lambda: np.array([]))\r\n    \r\n    if2_proto_norm_x: np.ndarray = field(default_factory=lambda: np.array([]))\r\n    if2_proto_val_y: np.ndarray = field(default_factory=lambda: np.array([]))\r\n\r\n    # New: IF1 harmonic model as list of (k, rel_dBc) pairs.\r\n    # k : positive integer harmonic index (1 = fundamental).\r\n    # rel_dBc : amplitude of that harmonic relative to the fundamental (0 dBc).\r\n    if1_harmonics: List[Tuple[int, float]] = field(default_factory=list)\r\n    \r\n    # Runtime / Pruning\r\n    runtime_lock_time_weight: float = 0.0\r\n    retune_penalty_weight: float = 0.0\r\n    prefer_fewer_retunes: bool = True\r\n    dominant_prune_cutoff_db: float = -20.0\r\n    dominant_spur_margin_buffer_db: float = 2.0\r\n    \r\n    markov_matrix: np.ndarray = field(default_factory=lambda: np.array([]))\r\n    markov_stationary: Optional[np.ndarray] = None\r\n\r\n    @staticmethod\r\n    def load(path: str):\r\n        with open(path, 'r') as f:\r\n            data = yaml.safe_load(f)\r\n        \r\n        cfg = GlobalConfig(yaml_data=data)\r\n        cfg._generate_tiles()\r\n        \r\n        grid_cfg = data.get('rbw_binning', {})\r\n        grid_glob = data.get('grids', {})\r\n        \r\n        # Grid steps plumbing\r\n        base_step = float(grid_cfg.get('lut_step_hz', 500e3))\r\n        cfg.if2_grid_step_hz = float(grid_cfg.get('if2_lut_step_hz', base_step))\r\n        cfg.rf_grid_step_hz = float(grid_cfg.get('rf_lut_step_hz', cfg.if2_grid_step_hz))\r\n        cfg.mask_grid_step_hz = float(grid_cfg.get('mask_lut_step_hz', cfg.rf_grid_step_hz))\r\n        \r\n        # Phase-1 simplification: enforce a single grid step for all LUTs\r\n        if not (cfg.if2_grid_step_hz == cfg.rf_grid_step_hz == cfg.mask_grid_step_hz):\r\n            print(\r\n                \"Warning: distinct grid steps requested for IF2/RF/mask, \"\r\n                \"but Phase-1 engine uses a common step. \"\r\n                f\"Using rf_grid_step_hz={cfg.rf_grid_step_hz} for all LUTs.\"\r\n            )\r\n        cfg.grid_step_hz = cfg.rf_grid_step_hz\r\n        \r\n        cfg.grid_max_freq_hz = float(grid_glob.get('grid_max_freq_hz', 65e9))\r\n        cfg.rbw_hz = float(grid_cfg.get('rbw_hz', cfg.rf_grid_step_hz))\r\n\r\n        orders_cfg = data.get('orders', {})\r\n        cfg.m1_max_order = int(orders_cfg.get('m1n1_max_abs', 7))\r\n        cfg.m2_max_order = int(orders_cfg.get('m2n2_max_abs', 7))\r\n        cfg.cross_stage_sum_max = int(orders_cfg.get('cross_stage_sum_max', 12))\r\n        \r\n        run_set = data.get('runtime_settings', {})\r\n        cfg.opt_cutoff_db = float(run_set.get('optimization_cutoff_db', -20.0))\r\n        cfg.noise_floor_dbc = float(run_set.get('noise_floor_cutoff_dbc', -100.0))\r\n        cfg.hysteresis_hz = float(run_set.get('hysteresis_hz', 50e6))\r\n        cfg.max_spur_level_dbc = float(run_set.get('max_spur_level_dbc', 0.0))\r\n        cfg.rf_passband_max_atten_db = float(run_set.get('rf_passband_max_atten_db', 5.0))\r\n        cfg.runtime_lock_time_weight = float(run_set.get('runtime_lock_time_weight', 0.0))\r\n        cfg.retune_penalty_weight = float(run_set.get('retune_penalty_weight', 0.0))\r\n        cfg.dominant_prune_cutoff_db = float(run_set.get('dominant_prune_cutoff_db', -20.0))\r\n        cfg.dominant_spur_margin_buffer_db = float(run_set.get('dominant_spur_margin_buffer_db', 2.0))\r\n\r\n        targ = data.get('targets', {})\r\n        cfg.min_margin_db = float(targ.get('min_margin_db', 0.0))\r\n\r\n        # ------------------------------------------------------------------\r\n        # IF1 harmonic spectrum config\r\n        # ------------------------------------------------------------------\r\n        if1_model = data.get(\"if1_model\", {}) or {}\r\n        harmonics_cfg = if1_model.get(\"harmonics\", []) or []\r\n\r\n        harmonics: List[Tuple[int, float]] = []\r\n        for idx, h in enumerate(harmonics_cfg):\r\n            try:\r\n                k = int(h.get(\"k\", 1))\r\n                rel = float(h.get(\"rel_dBc\", 0.0))\r\n            except Exception as ex:\r\n                print(\r\n                    f\"Warning: skipping malformed if1_model.harmonics[{idx}]: {h!r} \"\r\n                    f\"(error: {ex})\"\r\n                )\r\n                continue\r\n\r\n            if k < 1:\r\n                print(\r\n                    f\"Warning: skipping IF1 harmonic with non-positive k={k!r} \"\r\n                    f\"in if1_model.harmonics[{idx}]\"\r\n                )\r\n                continue\r\n\r\n            harmonics.append((k, rel))\r\n\r\n        if not harmonics:\r\n            # Backwards-compatible default: ideal single-tone IF1.\r\n            harmonics = [(1, 0.0)]\r\n            print(\r\n                \"Info: no valid IF1 harmonics configured; \"\r\n                \"defaulting to [(1, 0.0)] (ideal single-tone IF1).\"\r\n            )\r\n\r\n        cfg.if1_harmonics = harmonics\r\n        # ------------------------------------------------------------------\r\n\r\n        # Constraints & Desired Path\r\n        con = data.get('constraints', {})\r\n        cfg.enforce_desired_mn11_only = bool(con.get('enforce_desired_mn11_only', True))\r\n        cfg.desired_stage1_mn = tuple(con.get('desired_stage1_mn', [1, 1]))\r\n        cfg.desired_stage2_mn = tuple(con.get('desired_stage2_mn', [1, 1]))\r\n        \r\n        if cfg.desired_stage1_mn != (1, 1) or cfg.desired_stage2_mn != (1, 1):\r\n            raise NotImplementedError(\r\n                \"Only (1,1) desired orders are supported in this phase. \"\r\n                \"Non-(1,1) desired m,n will be added in a later phase.\"\r\n            )\r\n\r\n        # runtime_policy overrides\r\n        rt_policy = data.get('runtime_policy', {})\r\n        if 'hysteresis_hz' in rt_policy:\r\n            cfg.hysteresis_hz = float(rt_policy['hysteresis_hz'])\r\n        cfg.prefer_fewer_retunes = bool(rt_policy.get('prefer_fewer_retunes', True))\r\n        \r\n        mtx_path = rt_policy.get('markov_transition_matrix_csv')\r\n        if mtx_path:\r\n            try:\r\n                cfg.markov_matrix = np.loadtxt(mtx_path, delimiter=',')\r\n                cfg._compute_stationary()\r\n            except Exception as e:\r\n                print(f\"Warning: failed to load Markov matrix '{mtx_path}': {e}\")\r\n\r\n        # Load Hardware Filters\r\n        hw_choices = data.get('hardware_choices', {}).get('stacks', [])\r\n        rf_file = hw_choices[0].get('rf_bpf_file', None) if hw_choices else None\r\n        cfg._build_filter_profile(rf_file, is_rf=True, strict=False) \r\n        \r\n        # Load IF2 Prototype if enabled\r\n        if2_opts = data.get('if2_model', {}).get('scaled_s2p', {})\r\n        if if2_opts.get('enabled', False):\r\n            proto_file = if2_opts.get('prototype_s2p_file')\r\n            cfg._build_filter_profile(proto_file, is_rf=False, strict=True)\r\n            \r\n        return cfg\r\n\r\n    def _compute_stationary(self):\r\n        P = self.markov_matrix\r\n        if P.size == 0:\r\n            self.markov_stationary = None\r\n            return\r\n\r\n        n = P.shape[0]\r\n        if n != len(self.tiles):\r\n            print(f\"Warning: Markov matrix size {n} != num_tiles {len(self.tiles)}\")\r\n            return\r\n\r\n        dist = np.ones(n) / n\r\n        for _ in range(1000):\r\n            dist_new = dist @ P\r\n            if np.max(np.abs(dist_new - dist)) < 1e-10:\r\n                dist = dist_new\r\n                break\r\n            dist = dist_new\r\n        self.markov_stationary = dist\r\n\r\n    def _generate_tiles(self):\r\n        g = self.yaml_data['grids']\r\n        b = self.yaml_data['bands']\r\n        if1_min, if1_max = float(b['if1_hz']['min']), float(b['if1_hz']['max'])\r\n        rf_min, rf_max = float(b['rf_hz']['min']), float(b['rf_hz']['max'])\r\n        \r\n        if1s = np.arange(if1_min, if1_max + 1e5, g['if1_center_step_hz'])\r\n        rfs = np.arange(rf_min, rf_max + 1e5, g['rf_center_step_hz'])\r\n        bws = g['bw_grid_hz']\r\n        \r\n        tid = 0\r\n        for bw in bws:\r\n            for if1 in if1s:\r\n                if (if1 - bw/2) < if1_min or (if1 + bw/2) > if1_max:\r\n                    continue\r\n                for rf in rfs:\r\n                    self.tiles.append(Tile(tid, if1, bw, rf))\r\n                    tid += 1\r\n\r\n    def _build_filter_profile(self, file_path, is_rf=True, strict=False):\r\n        freqs, atten = np.array([]), np.array([])\r\n        loaded = False\r\n        \r\n        if file_path and os.path.exists(file_path):\r\n            try:\r\n                freqs, vals = self._parse_touchstone(file_path)\r\n                if len(freqs) > 0:\r\n                    atten = -vals if np.mean(vals) < 0 else vals\r\n                    loaded = True\r\n            except Exception as e:\r\n                if strict: raise ValueError(f\"Failed to parse filter file '{file_path}': {e}\")\r\n                print(f\"Warning: Failed to load filter {file_path}: {e}\")\r\n        elif strict and file_path:\r\n             raise FileNotFoundError(f\"Filter file required but not found: {file_path}\")\r\n\r\n        # Fallback for RF\r\n        if not loaded and is_rf:\r\n            if strict and file_path: raise ValueError(\"RF Filter load failed in strict mode.\")\r\n            b = self.yaml_data['bands']['rf_hz']\r\n            f_min, f_max = b['min'], b['max']\r\n            margin = 0.05 * (f_max - f_min)\r\n            \r\n            freqs = np.array([\r\n                0, f_min - 2*margin, f_min, f_max, f_max + 2*margin, 100e9\r\n            ])\r\n            atten = np.array([80, 80, 1.5, 1.5, 80, 80])\r\n            \r\n        if is_rf: \r\n            self.rf_filter_raw_freqs, self.rf_filter_raw_atten = freqs, atten\r\n        elif loaded:\r\n            self._normalize_prototype(freqs, atten, strict=strict)\r\n\r\n    def _normalize_prototype(self, freqs, atten, strict: bool = False):\r\n        if len(freqs) == 0:\r\n            raise ValueError(\"S2P file data is empty\")\r\n\r\n        method = self.yaml_data.get('runtime_settings', {}).get(\r\n            's2p_normalization_method', '3db_width'\r\n        )\r\n        if method != '3db_width':\r\n            print(f\"Warning: s2p_normalization_method='{method}' \"\r\n                  f\"is not implemented. Falling back to '3db_width'.\")\r\n\r\n        min_idx = np.argmin(atten)\r\n        f_center = freqs[min_idx]\r\n        min_loss = atten[min_idx]\r\n        \r\n        target_loss = min_loss + 3.0\r\n        \r\n        f_lower = f_center\r\n        for i in range(min_idx, -1, -1):\r\n            if atten[i] >= target_loss:\r\n                f_lower = freqs[i]\r\n                break\r\n                \r\n        f_upper = f_center\r\n        for i in range(min_idx, len(freqs)):\r\n            if atten[i] >= target_loss:\r\n                f_upper = freqs[i]\r\n                break\r\n        \r\n        bw_meas = f_upper - f_lower\r\n        \r\n        if bw_meas <= 0 or bw_meas < (freqs[-1] - freqs[0]) * 0.001:\r\n            msg = (\"Auto-detected BW from S2P seems invalid. \"\r\n                   \"Check S2P quality or normalization method.\")\r\n            if strict:\r\n                raise ValueError(msg)\r\n            print(\"Warning:\", msg, \"Defaulting to unit-width normalization.\")\r\n            bw_meas = 1.0\r\n            if f_center <= 0:\r\n                f_center = (freqs[-1] + freqs[0]) / 2.0\r\n        \r\n        self.if2_proto_norm_x = (freqs - f_center) / bw_meas\r\n        self.if2_proto_val_y = atten\r\n\r\n    def _parse_touchstone(self, file_path: str) -> Tuple[np.ndarray, np.ndarray]:\r\n        freqs, s21_db = [], []\r\n        scale_factor = 1.0\r\n        units = {'HZ': 1.0, 'KHZ': 1e3, 'MHZ': 1e6, 'GHZ': 1e9}\r\n        \r\n        with open(file_path, 'r') as f:\r\n            for line in f:\r\n                clean_line = line.split('!')[0].strip().upper()\r\n                if not clean_line: continue\r\n                \r\n                if clean_line.startswith('#'):\r\n                    parts = clean_line.split()\r\n                    for u, factor in units.items():\r\n                        if u in parts:\r\n                            scale_factor = factor\r\n                            break\r\n                    continue\r\n                    \r\n                if clean_line.startswith(\"VAR\") or clean_line.startswith(\"BEGIN\"): continue\r\n                \r\n                try:\r\n                    parts = clean_line.replace(',', ' ').split()\r\n                    if len(parts) < 2: continue\r\n                    f_val = float(parts[0])\r\n                    val = 0.0\r\n                    if len(parts) == 2: val = float(parts[1]) \r\n                    elif len(parts) == 3: val = float(parts[1]) \r\n                    elif len(parts) >= 9: val = float(parts[3]) \r\n                    else: val = float(parts[1])\r\n                    freqs.append(f_val * scale_factor)\r\n                    s21_db.append(val)\r\n                except ValueError: continue\r\n        \r\n        freqs = np.array(freqs)\r\n        if scale_factor == 1.0 and len(freqs) > 0 and np.max(freqs) < 200.0:\r\n             freqs *= 1e9\r\n        return freqs, np.array(s21_db)\r\n",
              "encoding": "utf-8",
              "encoding_error": false
            },
            {
              "type": "file",
              "name": "buc_validation.py",
              "path": "src\\buc\\buc_validation.py",
              "size": 1674,
              "content_truncated": false,
              "contents": "from .buc_engine import SpurEngine\r\nfrom .buc_models import HardwareStack\r\n\r\ndef basic_validation(cfg, stack_def, if2_filter):\r\n    \"\"\"\r\n    Basic validation per TDS §14 (coarse vs full-order sparse):\r\n    - Compares search-mode vs full-order sparse margins for a few tiles.\r\n    Prints warning if divergence exceeds a small tolerance.\r\n\r\n    NOTE: This is not a dense per-tone simulation; it's 'coarse vs fine\r\n    sparse' rather than 'sparse vs dense' as in the full TDS.\r\n    \"\"\"\r\n    hw = HardwareStack(cfg, stack_def)\r\n    engine = SpurEngine(cfg, hw)\r\n    \r\n    if not cfg.tiles:\r\n        print(\"No tiles to validate.\")\r\n        return\r\n        \r\n    tiles_to_check = cfg.tiles[:3]  # first few tiles\r\n    tol_db = 0.5\r\n    \r\n    print(\"Running Basic Validation (Search Mode vs Full Physics)...\")\r\n    for t in tiles_to_check:\r\n        m_sum_search = engine._eval_chain_fast(t, if2_filter, high_side=False, search_mode=True)\r\n        m_sum_full = engine._eval_chain_fast(t, if2_filter, high_side=False, search_mode=False)\r\n        \r\n        m_diff_search = engine._eval_chain_fast(t, if2_filter, high_side=True, search_mode=True)\r\n        m_diff_full = engine._eval_chain_fast(t, if2_filter, high_side=True, search_mode=False)\r\n        \r\n        for label, ms, mf in (\r\n            (\"Sum\", m_sum_search, m_sum_full),\r\n            (\"Diff\", m_diff_search, m_diff_full),\r\n        ):\r\n            if ms <= -900 or mf <= -900:\r\n                continue\r\n            if abs(ms - mf) > tol_db:\r\n                print(f\"Validation warning: Tile {t.id}, {label} path \"\r\n                      f\"search/full mismatch {ms:.2f} vs {mf:.2f} dB.\")\r\n    print(\"Validation Complete.\")",
              "encoding": "utf-8",
              "encoding_error": false
            },
            {
              "type": "file",
              "name": "buc_visuals.py",
              "path": "src\\buc\\buc_visuals.py",
              "size": 6185,
              "content_truncated": false,
              "contents": "import pandas as pd\r\nimport matplotlib.pyplot as plt\r\nimport numpy as np\r\nfrom matplotlib.colors import LinearSegmentedColormap  # <- NEW\r\n\r\ndef plot_margin_heatmap(df_policy: pd.DataFrame, filename: str = \"heatmap_margin.png\"):\r\n    \"\"\"\r\n    Generates a 2D heatmap of Spur Margin vs IF1 and RF Center frequencies.\r\n    \"\"\"\r\n    if df_policy.empty:\r\n        print(\"No policy data to plot.\")\r\n        return\r\n\r\n    # Work on a copy to avoid modifying the original df passed in memory\r\n    df = df_policy.copy()\r\n\r\n    # Validation: Ensure we have the required columns for axes\r\n    required_cols = {'if1_center_hz', 'rf_center_hz'}\r\n    missing = required_cols - set(df.columns)\r\n    if missing:\r\n        print(f\"Error: Missing required columns for heatmap axes: {missing}\")\r\n        return\r\n\r\n    # Normalization: Ensure target column exists\r\n    if 'spur_margin_db' not in df.columns and 'margin' in df.columns:\r\n        df['spur_margin_db'] = df['margin']\r\n    \r\n    if 'spur_margin_db' not in df.columns:\r\n        print(\"Error: 'spur_margin_db' column missing from policy dataframe.\")\r\n        return\r\n\r\n    # Handle sentinel \"no-solution\" margins (e.g. -999.0) as NaN so they stand out\r\n    margins = df[\"spur_margin_db\"].astype(float).copy()\r\n    sentinel_mask = margins <= -800.0\r\n    margins[sentinel_mask] = np.nan\r\n    df[\"spur_margin_db\"] = margins\r\n\r\n    # Pivot Data\r\n    # X-axis: IF1, Y-axis: RF, Value: Margin\r\n    pivot = df.pivot_table(\r\n        index='rf_center_hz', \r\n        columns='if1_center_hz', \r\n        values='spur_margin_db',\r\n        aggfunc='mean'  # Handle duplicates if any by averaging\r\n    )\r\n\r\n    if pivot.empty:\r\n        print(\"No pivot data to plot.\")\r\n        return\r\n    \r\n    # Ensure sorted axes\r\n    pivot = pivot.sort_index().sort_index(axis=1)\r\n    \r\n    # Convert index/cols for readability\r\n    rf_axis = pivot.index.to_numpy() / 1e9     # RF in GHz\r\n    if1_axis = pivot.columns.to_numpy() / 1e6  # IF1 in MHz\r\n    \r\n    plt.figure(figsize=(12, 8))\r\n\r\n    # ------------------------------------------------------------------\r\n    # Custom colormap:\r\n    # - For margins < 0: light red (near 0 dB) to dark red (−5 dB)\r\n    # - For margins > 0: light green (near 0 dB) to dark green (+5 dB)\r\n    # - 0 is a hard color boundary between red and green\r\n    # - NaNs (no-solution) will be white\r\n    # ------------------------------------------------------------------\r\n    dark_red   = (0.6, 0.0, 0.0)   # stronger fail\r\n    light_red  = (1.0, 0.8, 0.8)   # just-barely fail\r\n    light_green = (0.8, 1.0, 0.8)  # just-barely pass\r\n    dark_green  = (0.0, 0.4, 0.0)  # strong pass\r\n\r\n    cdict = {\r\n        # x in [0, 1] corresponds to margin in [-5, +5] via vmin/vmax\r\n        # x = 0   -> -5 dB (dark_red)\r\n        # x = 0.5 ->  0 dB (transition from light_red to light_green)\r\n        # x = 1   -> +5 dB (dark_green)\r\n        'red': (\r\n            (0.0, dark_red[0],   dark_red[0]),\r\n            (0.5, light_red[0],  light_green[0]),\r\n            (1.0, dark_green[0], dark_green[0]),\r\n        ),\r\n        'green': (\r\n            (0.0, dark_red[1],   dark_red[1]),\r\n            (0.5, light_red[1],  light_green[1]),\r\n            (1.0, dark_green[1], dark_green[1]),\r\n        ),\r\n        'blue': (\r\n            (0.0, dark_red[2],   dark_red[2]),\r\n            (0.5, light_red[2],  light_green[2]),\r\n            (1.0, dark_green[2], dark_green[2]),\r\n        ),\r\n    }\r\n\r\n    margin_cmap = LinearSegmentedColormap('FailPassMargin', cdict, N=256)\r\n    margin_cmap.set_bad('white')  # keep NaNs as white = \"no solution\"\r\n    # ------------------------------------------------------------------\r\n\r\n    # Create Heatmap\r\n    im = plt.imshow(\r\n        pivot.to_numpy(), \r\n        aspect='auto', \r\n        origin='lower', \r\n        cmap=margin_cmap,  # <- use our custom colormap\r\n        vmin=-5.0, \r\n        vmax=5.0,\r\n        extent=[if1_axis.min(), if1_axis.max(), rf_axis.min(), rf_axis.max()]\r\n    )\r\n    \r\n    cbar = plt.colorbar(im)\r\n    cbar.set_label('Spur Margin (dB)')\r\n    \r\n    plt.xlabel('IF1 Center Frequency (MHz)')\r\n    plt.ylabel('RF Center Frequency (GHz)')\r\n    plt.title('BUC Spur Margin Heatmap\\n(Green = Pass, Red = Fail, White = No Solution)')\r\n    plt.grid(False)\r\n    \r\n    plt.tight_layout()\r\n    plt.savefig(filename, dpi=150)\r\n    print(f\"Heatmap saved to {filename}\")\r\n    plt.close()\r\n\r\n\r\ndef plot_if2_filter(engine, if2_filter, csv_path: str = \"if2_filter_response.csv\",\r\n                    png_path: str = \"if2_filter_response.png\"):\r\n    \"\"\"\r\n    Export and plot the final IF2 filter attenuation vs frequency.\r\n\r\n    Uses the engine's current IF2 LUT (engine.if2_lut_buffer), which must have\r\n    been built for 'if2_filter' via engine.build_policy_for_if2(...) or\r\n    engine.evaluate_policy(...).\r\n\r\n    CSV columns: freq_hz, if2_atten_db\r\n    \"\"\"\r\n    import matplotlib.pyplot as plt\r\n    import numpy as np\r\n    import pandas as pd\r\n\r\n    lut = engine.if2_lut_buffer\r\n    step = engine.grid_step       # Hz per bin\r\n    n_bins = len(lut)\r\n\r\n    # Limit plot/export to a sensible window around the filter:\r\n    # same spirit as fill_symmetric_filter_lut -> ±5 * BW around center\r\n    span_hz = 5.0 * if2_filter.bw_hz\r\n    f_start = max(0.0, if2_filter.center_hz - span_hz)\r\n    f_stop  = min(engine.grid_max, if2_filter.center_hz + span_hz)\r\n\r\n    idx0 = max(0, int(f_start / step))\r\n    idx1 = min(n_bins, int(f_stop / step) + 1)\r\n\r\n    freqs = np.arange(idx0, idx1) * step\r\n    atten = lut[idx0:idx1].copy()\r\n\r\n    # --- CSV export ---\r\n    df = pd.DataFrame({\r\n        \"freq_hz\": freqs,\r\n        \"if2_gain_db\": -atten,\r\n    })\r\n    df.to_csv(csv_path, index=False)\r\n    print(f\"IF2 filter response CSV written to {csv_path}\")\r\n\r\n    # --- Plot ---\r\n    plt.figure(figsize=(10, 6))\r\n    plt.plot(freqs / 1e9, -atten)\r\n    plt.xlabel(\"Frequency (GHz)\")\r\n    plt.ylabel(\"IF2 Gain (dB)\")\r\n    plt.title(\r\n        f\"IF2 Filter Response\\n\"\r\n        f\"center = {if2_filter.center_hz/1e9:.3f} GHz, \"\r\n        f\"BW = {if2_filter.bw_hz/1e6:.1f} MHz\"\r\n    )\r\n    plt.grid(True)\r\n    plt.tight_layout()\r\n    plt.savefig(png_path, dpi=150)\r\n    print(f\"IF2 filter response plot saved to {png_path}\")\r\n    plt.close()\r\n",
              "encoding": "utf-8",
              "encoding_error": false
            }
          ]
        },
        {
          "type": "directory",
          "name": "bucso2_repo.egg-info",
          "path": "src\\bucso2_repo.egg-info",
          "children": [
            {
              "type": "file",
              "name": "dependency_links.txt",
              "path": "src\\bucso2_repo.egg-info\\dependency_links.txt",
              "size": 1,
              "content_truncated": false,
              "contents": "\n",
              "encoding": "utf-8",
              "encoding_error": false
            },
            {
              "type": "file",
              "name": "PKG-INFO",
              "path": "src\\bucso2_repo.egg-info\\PKG-INFO",
              "size": 406,
              "content_truncated": false,
              "contents": "Metadata-Version: 2.4\r\nName: bucso2-repo\r\nVersion: 0.1.0\r\nSummary: Add your description here\r\nRequires-Python: >=3.13\r\nDescription-Content-Type: text/markdown\r\nRequires-Dist: colorama>=0.4.6\r\nRequires-Dist: matplotlib>=3.10.7\r\nRequires-Dist: numba>=0.62.1\r\nRequires-Dist: numpy>=2.3.5\r\nRequires-Dist: pandas>=2.3.3\r\nRequires-Dist: pytest>=9.0.1\r\nRequires-Dist: pyyaml>=6.0.3\r\nRequires-Dist: scipy>=1.16.3\r\n",
              "encoding": "utf-8",
              "encoding_error": false
            },
            {
              "type": "file",
              "name": "requires.txt",
              "path": "src\\bucso2_repo.egg-info\\requires.txt",
              "size": 118,
              "content_truncated": false,
              "contents": "colorama>=0.4.6\nmatplotlib>=3.10.7\nnumba>=0.62.1\nnumpy>=2.3.5\npandas>=2.3.3\npytest>=9.0.1\npyyaml>=6.0.3\nscipy>=1.16.3\n",
              "encoding": "utf-8",
              "encoding_error": false
            },
            {
              "type": "file",
              "name": "SOURCES.txt",
              "path": "src\\bucso2_repo.egg-info\\SOURCES.txt",
              "size": 429,
              "content_truncated": false,
              "contents": "README.md\npyproject.toml\nsrc/buc/__init__.py\nsrc/buc/buc_diagnostics.py\nsrc/buc/buc_engine.py\nsrc/buc/buc_kernels.py\nsrc/buc/buc_markov.py\nsrc/buc/buc_models.py\nsrc/buc/buc_structures.py\nsrc/buc/buc_validation.py\nsrc/buc/buc_visuals.py\nsrc/bucso2_repo.egg-info/PKG-INFO\nsrc/bucso2_repo.egg-info/SOURCES.txt\nsrc/bucso2_repo.egg-info/dependency_links.txt\nsrc/bucso2_repo.egg-info/requires.txt\nsrc/bucso2_repo.egg-info/top_level.txt",
              "encoding": "utf-8",
              "encoding_error": false
            },
            {
              "type": "file",
              "name": "top_level.txt",
              "path": "src\\bucso2_repo.egg-info\\top_level.txt",
              "size": 4,
              "content_truncated": false,
              "contents": "buc\n",
              "encoding": "utf-8",
              "encoding_error": false
            }
          ]
        }
      ]
    },
    {
      "type": "file",
      "name": ".gitignore",
      "path": ".gitignore",
      "size": 109,
      "content_truncated": false,
      "contents": "# Python-generated files\n__pycache__/\n*.py[oc]\nbuild/\ndist/\nwheels/\n*.egg-info\n\n# Virtual environments\n.venv\n",
      "encoding": "utf-8",
      "encoding_error": false
    },
    {
      "type": "file",
      "name": ".python-version",
      "path": ".python-version",
      "size": 5,
      "content_truncated": false,
      "contents": "3.13\n",
      "encoding": "utf-8",
      "encoding_error": false
    },
    {
      "type": "file",
      "name": "config.yaml",
      "path": "config.yaml",
      "size": 10829,
      "content_truncated": false,
      "contents": "project:\r\n  name: \"KaBUC_LTC5553_ADMV1550\"\r\n  seed: 42\r\n  reference_10mhz_hz: 10000000\r\n\r\nbands:\r\n  if1_hz: {min: 950.0e+6, max: 2450.0e+6}   # 950 MHz – 2.45 GHz\r\n  rf_hz:  {min: 28.25e+9, max: 30.25e+9}      # 27.5 GHz – 31.0 GHz\r\n  required_bandwidths_hz: [1500.0e+6]\r\n\r\nif1_model:\r\n  harmonics:\r\n    - k: 1\r\n      rel_dBc: 0.0      # fundamental IF1\r\n    - k: 2\r\n      rel_dBc: -30.0    # 2nd harmonic at -30 dBc\r\n    - k: 3\r\n      rel_dBc: -40.0    # 3rd harmonic at -40 dBc\r\n\r\ngrids:\r\n  # Tile discretization; you can tighten these if you want more tiles\r\n  if1_center_step_hz: 50.0e+6\r\n  rf_center_step_hz: 1000.0e+6\r\n  bw_grid_hz: [1500.0e+6]\r\n  snap_if1_rf_to_grid: true\r\n  grid_max_freq_hz: 50.0e+9\r\n\r\nmasks:\r\n  inband:\r\n    default_dbc: -60.0\r\n    table: []\r\n  outofband:\r\n    default_dbc: -60.0\r\n    table: []\r\n\r\nrbw_binning:\r\n  lut_step_hz: 5.0e+5\r\n  rbw_hz: 5.0e+5\r\n\r\nhardware_choices:\r\n  stacks:\r\n    - name: \"KaBUC_LTC5553_ADMV1550\"\r\n      mixer1: \"LTC5553_MXR1\"\r\n      mixer2: \"ADMV1550_MXR2\"\r\n      lo1: \"LMX2594_LO1\"\r\n      lo2: \"ADF4371_LO2\"\r\n      rf_bpf_file: \"RF_S21_28to31GHz.csv\" \r\n\r\norders:\r\n  m1n1_max_abs: 4\r\n  m2n2_max_abs: 4\r\n  cross_stage_sum_max: 16\r\n\r\nconstraints:\r\n  guard_margin_db: 0.0\r\n  enforce_non_inverting_chain: true\r\n  enforce_desired_mn11_only: true  # Phase-1 assumption\r\n  desired_stage1_mn: [1, 1]\r\n  desired_stage2_mn: [1, 1]\r\n\r\ntargets:\r\n  min_margin_db: -30.0\r\n\r\nruntime_settings:\r\n  optimization_cutoff_db: -30.0\r\n  noise_floor_cutoff_dbc: -100.0\r\n  s2p_normalization_method: \"3db_width\"\r\n  hysteresis_hz: 50.0e6\r\n\r\n  # Physics/Policy Knobs\r\n  runtime_lock_time_weight: 0.0\r\n  max_spur_level_dbc: 0.0       # 0 = no clamp\r\n  rf_passband_max_atten_db: 5.0\r\n  dominant_prune_cutoff_db: -20.0\r\n  dominant_spur_margin_buffer_db: 2.0\r\n\r\nif2_model:\r\n  name: \"IF2_Model_01\"\r\n  type: \"symmetric_powerlaw\"\r\n  passband_il_db: 1.0\r\n  stop_floor_db: 80.0\r\n  rolloff_db_per_dec: 100.0\r\n  min_bw_hz: 1500.0e6\r\n  max_bw_hz: 2000.0e6\r\n  # IF2 roughly in a comfortable region for LTC5553 (RF port) and ADMV1550 IF\r\n  center_range_hz: [4.0e9, 20.0e9]\r\n\r\n  scaled_s2p:\r\n    enabled: false\r\n    prototype_s2p_file: \"if2_prototype_normalized.s2p\"\r\n\r\n  search:\r\n    coarse_center_step_hz: 50.0e6\r\n    coarse_bw_step_hz: 50.0e6\r\n    top_k_seeds_for_refinement: 10\r\n\r\nearly_reject:\r\n  image_in_if2_passband: false\r\n  loft_in_if2_or_rf_passbands: false\r\n  rf_first_order_image_in_passband: false\r\n\r\nruntime_policy:\r\n  hysteresis_hz: 50.0e6\r\n  prefer_fewer_retunes: true\r\n  markov_transition_matrix_csv: null\r\n\r\n# -------------------------------------------------------------------\r\n# Mixer Models\r\n# -------------------------------------------------------------------\r\n\r\nmixers:\r\n  # Mixer 1: LTC5553 (3 GHz–20 GHz RF/LO, 500 MHz–9 GHz IF)\r\n  - name: \"LTC5553_MXR1\"\r\n    lo_range_hz: [3.0e9, 32.0e9]\r\n    required_lo_drive_dbm: {min: -6.0, max: +6.0}   # nominal ~0 dBm\r\n    isolation:\r\n      lo_to_rf_db: -25.0 # Not dangerous\r\n      if_to_rf_db: -40.0 # Not dangerous\r\n    include_isolation_spurs: true\r\n\r\n    # LO drive derating & family scaling\r\n    drive_derate:\r\n      nominal_dbm: 0.0\r\n      slope_db_per_db: 1.0\r\n      max_derate_db: 6.0\r\n\r\n    lo_family_scaling:\r\n      default_slope_db_per_db: 1.0\r\n      cap_db: 12.0\r\n\r\n    # Generic spur table (you can refine these from bench data later)\r\n    spur_list:\r\n      - [0, 1, -51]\r\n      - [0, 2, -58]\r\n      - [0, 3, -75]\r\n      - [0, 4, -75]\r\n\r\n      - [1, 0, -24]\r\n      - [1, 1, -0.0] # desired fundamental\r\n      - [1, 2, -64]\r\n      - [1, 3, -72]\r\n      - [1, 4, -75]\r\n\r\n      - [2, 0, -15]\r\n      - [2, 1, -42] # <--- CRITICAL VALUE!\r\n      - [2, 2, -58]\r\n      - [2, 3, -72]\r\n      - [2, 4, -73]\r\n\r\n      - [3, 0, -16]\r\n      - [3, 1, -13]\r\n      - [3, 2, -61]\r\n      - [3, 3, -71]\r\n      - [3, 4, -73]\r\n\r\n      - [4, 0, -20]\r\n      - [4, 1, -53]\r\n      - [4, 2, -62]\r\n      - [4, 3, -75]\r\n      - [4, 4, -75]\r\n\r\n  # Mixer 2-1: ADMV1550 (15–65 GHz RF/LO, DC–20 GHz IF)\r\n  - name: \"ADMV1550_MXR2\"\r\n    lo_range_hz: [15.0e9, 65.0e9]\r\n    required_lo_drive_dbm: {min: +12.0, max: +18.0}  # nominal ~+15 dBm\r\n    isolation:\r\n      lo_to_rf_db: -35.0 # Not dangerous\r\n      if_to_rf_db: -45.0 # Not dangerous\r\n    include_isolation_spurs: true\r\n\r\n    drive_derate:\r\n      nominal_dbm: 15.0\r\n      slope_db_per_db: 1.0\r\n      max_derate_db: 6.0\r\n\r\n    lo_family_scaling:\r\n      default_slope_db_per_db: 1.0\r\n      cap_db: 12.0\r\n\r\n    spur_list:\r\n    # Format: [m (LO), n (IF), relative_dBc]\r\n    # Tables OFTEN use the opposite LO/IF m-n convention!!! Be careful.\r\n      - [0, 1, -55]\r\n      - [0, 2, -89]\r\n      - [0, 3, -89] \r\n      - [0, 4, -87]\r\n\r\n      - [1, 0, -5]\r\n      - [1, 1, -0.0] # desired fundamental\r\n      - [1, 2, -46]\r\n      - [1, 3, -73]\r\n      - [1, 4, -74]\r\n\r\n      - [2, 0, -3]\r\n      - [2, 1, -41]\r\n      - [2, 2, -61]\r\n      - [2, 3, -63]\r\n      - [2, 4, -60]\r\n\r\n      - [3, 0, -3]\r\n      - [3, 1, -11]\r\n      - [3, 2, -50]\r\n      - [3, 3, -65]\r\n      - [3, 4, -65]\r\n\r\n      - [4, 0, -3]\r\n      - [4, 1, -11]\r\n      - [4, 2, -51]\r\n      - [4, 3, -65]\r\n      - [4, 4, -65]\r\n\r\n  # Mixer 2-2: MDB44H\r\n  - name: \"MDB44H_MXR2\"\r\n    lo_range_hz: [10.0e9, 40.0e9]\r\n    required_lo_drive_dbm: {min: +10.0, max: +21.0}  # nominal ~+15 dBm\r\n    isolation:\r\n      lo_to_rf_db: -37.0 # Not dangerous\r\n      if_to_rf_db: -16.0 # Not dangerous\r\n    include_isolation_spurs: true\r\n\r\n    drive_derate:\r\n      nominal_dbm: 15.0\r\n      slope_db_per_db: 1.0\r\n      max_derate_db: 6.0\r\n\r\n    lo_family_scaling:\r\n      default_slope_db_per_db: 1.0\r\n      cap_db: 12.0\r\n\r\n    spur_list:\r\n    # Format: [m (LO), n (IF), relative_dBc]\r\n    # Tables OFTEN use the opposite LO/IF m-n convention!!! Be careful.\r\n      - [0, 1, -9.41]\r\n      - [0, 2, -36.49]\r\n      - [0, 3, -37.0] \r\n      - [0, 4, -37.0]\r\n\r\n      - [1, 0, -23.51]\r\n      - [1, 1, -0.0] # desired fundamental\r\n      - [1, 2, -57.35]\r\n      - [1, 3, -35.1]\r\n      - [1, 4, -37.0]\r\n\r\n      - [2, 0, -31.28]\r\n      - [2, 1, -38.47]\r\n      - [2, 2, -50.69]\r\n      - [2, 3, -48.40]\r\n      - [2, 4, -59.68]\r\n\r\n      - [3, 0, -35.0]\r\n      - [3, 1, -40.0]\r\n      - [3, 2, -45.32]\r\n      - [3, 3, -33.25]\r\n      - [3, 4, -56.54]\r\n\r\n      - [4, 0, -30.0]\r\n      - [4, 1, -40.0]\r\n      - [4, 2, -40.0]\r\n      - [4, 3, -51.58]\r\n      - [4, 4, -57.08]\r\n\r\n# -------------------------------------------------------------------\r\n# LO Synthesizers\r\n# -------------------------------------------------------------------\r\n\r\nlos:\r\n  # LO1: LMX2594 (used to drive LTC5553)\r\n  - name: \"LMX2594_LO1\"\r\n    freq_range_hz: [10.0e6, 15.0e9]\r\n    step_hz: 1.0e3\r\n\r\n    # Approximate output power vs. frequency (from datasheet typicals)\r\n    output_power_model:\r\n      table:\r\n        freq_hz: [5.0e9, 10.0e9, 15.0e9]\r\n        p_out_dbm: [4.0, 4.0, 4.0]\r\n      divider_adjust_db:\r\n        \"/1\": 0\r\n        \"/2\": -1\r\n        \"/4\": -2\r\n        \"/8\": -3\r\n\r\n    distribution:\r\n      # LO distribution losses for this PLL\r\n      path_losses_db: {lo1: 3.0, lo2: 0.0}\r\n      pad_options_db: [0]\r\n\r\n    divider_spectrum:\r\n      \"/1\": { harm_delta_dBc: 0 }\r\n      \"/2\": { harm_delta_dBc: 6 }\r\n      \"/4\": { harm_delta_dBc: 12 }\r\n      \"/8\": { harm_delta_dBc: 18 }\r\n\r\n    modes:\r\n      - name: \"fracN\"\r\n        enabled: true\r\n        pfd_hz_range: [10.0e6, 200.0e6]\r\n        pfd_dividers: [1, 2, 4, 8]\r\n        vco_dividers: [1, 2, 4, 8, 16]\r\n\r\n        lock_time_model:\r\n          base_ms: 0.40\r\n          per_mhz_ms: 0.002\r\n          mode_penalties_ms:\r\n            int_to_frac: 0.30\r\n            frac_to_int: 0.20\r\n\r\n        harmonics:\r\n          - {k: 2, rel_dBc: -20.0} # Causes spur issues\r\n          - {k: 3, rel_dBc: -30.0} # Causes spur issues\r\n\r\n        # PFD spurs ~−90 dBc typical.\r\n        pfd_spurs_at_output:\r\n          families:\r\n            - name: \"k*fPFD\"\r\n              components:\r\n                - {k: 1, base_rel_dBc: -90.0, rolloff_dB_per_dec: 6.0}\r\n                - {k: 2, base_rel_dBc: -90.0, rolloff_dB_per_dec: 6.0}\r\n\r\n        frac_boundary_spurs:\r\n          enabled: true\r\n          amplitude_at_eps0p5_rel_dBc: -155.0\r\n          rolloff_slope_db_per_dec: 10.0\r\n\r\n  # LO2: ADF4371 (Ka-band LO for ADMV1550)\r\n  - name: \"ADF4371_LO2\"\r\n    # ADF4371 RF output range is 62.5 MHz to 32 GHz (via /8, /16, /32 paths)\r\n    freq_range_hz: [62.5e6, 32.0e9]\r\n    step_hz: 1.0e3   # 1 kHz fractional-N resolution (model assumption)\r\n\r\n    # Use typical maximum output power vs frequency from datasheet Table 1\r\n    # RF8x / RF16x / RF32x outputs at maximum power setting.\r\n    output_power_model:\r\n      table:\r\n        freq_hz:   [4.0e9,  8.0e9, 16.0e9, 32.0e9]\r\n        p_out_dbm: [18.0,    18.0,   18.0,    18.0]\r\n      # No divider-based power correction in this phase; keep neutral.\r\n      divider_adjust_db:\r\n        \"/1\":  0\r\n        \"/2\":  0\r\n        \"/4\":  0\r\n        \"/8\":  0\r\n        \"/16\": 0\r\n        \"/32\": 0\r\n\r\n    # Distribution from ADF4371 to ADMV1550 LO port.\r\n    # Keep the same assumptions as your previous LO2 entry unless you’ve\r\n    # measured the actual path loss.\r\n    distribution:\r\n      path_losses_db: {lo1: 0.0, lo2: 4.0}\r\n      pad_options_db: [0, 3, 6]\r\n\r\n    # Very simple divider spectrum model; you can refine later with\r\n    # your measured harmonic vs divider data if needed.\r\n    divider_spectrum:\r\n      \"/1\":  { harm_delta_dBc: 0 }\r\n      \"/2\":  { harm_delta_dBc: 0 }\r\n      \"/4\":  { harm_delta_dBc: 0 }\r\n      \"/8\":  { harm_delta_dBc: 0 }\r\n      \"/16\": { harm_delta_dBc: 0 }\r\n      \"/32\": { harm_delta_dBc: 0 }\r\n\r\n    modes:\r\n      - name: \"fracN\"\r\n        enabled: true\r\n\r\n        # PFD operation up to 250 MHz (datasheet).\r\n        pfd_hz_range: [10.0e6, 250.0e6]\r\n        pfd_dividers: [1, 2, 4, 8]\r\n        # Allow the engine to conceptually use various RF8x/RF16x/RF32x modes\r\n        # by representing them as VCO dividers.\r\n        vco_dividers: [1, 2, 4, 8, 16, 32]\r\n\r\n        # Lock-time model: ~3 ms for a reasonably large jump.\r\n        lock_time_model:\r\n          base_ms: 3.0     # auto-cal on\r\n          per_mhz_ms: 0.002\r\n          mode_penalties_ms:\r\n            int_to_frac: 0.0\r\n            frac_to_int: 0.0\r\n\r\n        # Harmonics: use typical worst-case ~−30 dBc as a global model.\r\n        harmonics:\r\n          - {k: 2, rel_dBc: -30.0} # Causes spur issues\r\n          - {k: 3, rel_dBc: -30.0} # Causes spur issues\r\n\r\n        # PFD spurs ~−90 dBc typical.\r\n        pfd_spurs_at_output:\r\n          families:\r\n            - name: \"k*fPFD\"\r\n              components:\r\n                - {k: 1, base_rel_dBc: -90.0, rolloff_dB_per_dec: 6.0}\r\n                - {k: 2, base_rel_dBc: -90.0, rolloff_dB_per_dec: 6.0}\r\n\r\n        # Integer-boundary spur: unfiltered inband ~−55 dBc.\r\n        frac_boundary_spurs:\r\n          enabled: true\r\n          amplitude_at_eps0p5_rel_dBc: -155.0\r\n          rolloff_slope_db_per_dec: 10.0\r\n",
      "encoding": "utf-8",
      "encoding_error": false
    },
    {
      "type": "file",
      "name": "main.py",
      "path": "main.py",
      "size": 15728,
      "content_truncated": false,
      "contents": "import time\r\nimport pandas as pd\r\nimport numpy as np\r\nimport hashlib\r\nimport json\r\nimport platform\r\nimport sys\r\nfrom pathlib import Path  # NEW\r\nfrom colorama import Fore, Style\r\nfrom multiprocessing import Pool, cpu_count\r\n\r\nfrom buc import (\r\n    GlobalConfig,\r\n    FilterModel,\r\n    HardwareStack,\r\n    SpurEngine,\r\n    generate_spur_ledger,\r\n    plot_margin_heatmap,\r\n    plot_if2_filter,\r\n    basic_validation,\r\n    markov_lock_summary,\r\n)\r\n\r\nworker_engine = None\r\n\r\n\r\ndef print_progress(current, total, prefix: str = \"\", length: int = 40, color=None):\r\n    \"\"\"\r\n    Simple in-terminal progress bar.\r\n\r\n    current : number of completed items\r\n    total   : total items\r\n    prefix  : text printed before the bar (e.g. '    ' or '  Scan ')\r\n    length  : bar width in characters\r\n    color   : optional colorama Fore.* color\r\n    \"\"\"\r\n    if total <= 0:\r\n        total = 1\r\n\r\n    frac = current / total\r\n    if frac < 0.0:\r\n        frac = 0.0\r\n    if frac > 1.0:\r\n        frac = 1.0\r\n\r\n    filled = int(length * frac)\r\n    bar = \"=\" * filled + \".\" * (length - filled)\r\n\r\n    color_prefix = color or \"\"\r\n    color_suffix = Style.RESET_ALL if color else \"\"\r\n\r\n    sys.stdout.write(\r\n        f\"\\r{prefix}{color_prefix}[{bar}] {100.0 * frac:5.1f}% ({current}/{total}){color_suffix}\"\r\n    )\r\n    sys.stdout.flush()\r\n\r\n    if current >= total:\r\n        sys.stdout.write(\"\\n\")\r\n        sys.stdout.flush()\r\n\r\n\r\ndef init_worker(config, stack_def):\r\n    global worker_engine\r\n    hw = HardwareStack(config, stack_def)\r\n    worker_engine = SpurEngine(config, hw)\r\n\r\n\r\ndef evaluate_wrapper(if2_model):\r\n    score, time_cost = worker_engine.evaluate_policy(if2_model, search_mode=True)\r\n    return (score, time_cost, if2_model)\r\n\r\n\r\ndef local_refinement(engine, seed_if2, initial_score, initial_time):\r\n    current_if2 = seed_if2\r\n    current_score = initial_score\r\n    current_time = initial_time\r\n\r\n    if2_cfg = engine.cfg.yaml_data['if2_model']\r\n    c_min, c_max = if2_cfg['center_range_hz']\r\n    c_min = float(c_min)\r\n    c_max = float(c_max)\r\n\r\n    bw_min = float(if2_cfg['min_bw_hz'])\r\n    bw_max = float(if2_cfg['max_bw_hz'])\r\n\r\n    freq_steps = [50e6, 10e6, 2e6]\r\n    bw_steps = [20e6, 5e6]\r\n\r\n    print(f\"{Fore.MAGENTA}--- Starting Local Refinement on Seed {seed_if2.center_hz/1e9:.2f}GHz ---{Style.RESET_ALL}\")\r\n\r\n    # Center refinement\r\n    for step in freq_steps:\r\n        improved = True\r\n        while improved:\r\n            improved = False\r\n            neighbors = []\r\n            base_c = current_if2.center_hz\r\n            for d in [-step, step]:\r\n                new_c = base_c + d\r\n                if new_c < c_min or new_c > c_max:\r\n                    continue\r\n                neighbors.append(FilterModel(\r\n                    new_c, current_if2.bw_hz,\r\n                    current_if2.model_type, current_if2.passband_il,\r\n                    current_if2.rolloff, current_if2.stop_floor\r\n                ))\r\n            for n in neighbors:\r\n                s, t = engine.evaluate_policy(n, search_mode=True)\r\n                is_better = False\r\n                if s > current_score + 0.01:\r\n                    is_better = True\r\n                elif abs(s - current_score) < 0.1 and t < current_time:\r\n                    is_better = True\r\n\r\n                if is_better:\r\n                    current_score, current_time, current_if2 = s, t, n\r\n                    improved = True\r\n                    print(f\"  > Improved Freq: {current_if2.center_hz/1e9:.3f}GHz -> {current_score:.2f} dB\")\r\n\r\n    # Bandwidth refinement\r\n    for step in bw_steps:\r\n        improved = True\r\n        while improved:\r\n            improved = False\r\n            neighbors = []\r\n            base_bw = current_if2.bw_hz\r\n            for d in [-step, step]:\r\n                new_bw = base_bw + d\r\n                if new_bw < bw_min or new_bw > bw_max:\r\n                    continue\r\n                neighbors.append(FilterModel(\r\n                    current_if2.center_hz, new_bw,\r\n                    current_if2.model_type, current_if2.passband_il,\r\n                    current_if2.rolloff, current_if2.stop_floor\r\n                ))\r\n            for n in neighbors:\r\n                s, t = engine.evaluate_policy(n, search_mode=True)\r\n                is_better = False\r\n                if s > current_score + 0.01:\r\n                    is_better = True\r\n                elif abs(s - current_score) < 0.1 and t < current_time:\r\n                    is_better = True\r\n\r\n                if is_better:\r\n                    current_score, current_time, current_if2 = s, t, n\r\n                    improved = True\r\n                    print(f\"  > Improved BW: {current_if2.bw_hz/1e6:.1f}MHz -> {current_score:.2f} dB\")\r\n\r\n    final_score, final_time = engine.evaluate_policy(current_if2, search_mode=False)\r\n    return current_if2, final_score, final_time, getattr(engine, \"last_retune_count\", None)\r\n\r\n\r\ndef build_policy_df_from_entries(entries, if2_filter, hw_stack, cfg):\r\n    rows = []\r\n    for e in entries:\r\n        lo1, lo2 = e.lo1, e.lo2\r\n        side = e.side\r\n\r\n        # Desired path tuples for this phase (fixed (1,1) family)\r\n        s1_tup = \"(1, -1)\" if side == \"high\" else \"(1, 1)\"\r\n        s2_tup = s1_tup\r\n\r\n        rows.append({\r\n            \"tile_id\": e.tile_id,\r\n            \"if1_center_hz\": e.if1_center_hz,\r\n            \"bw_hz\": e.bw_hz,\r\n            \"rf_center_hz\": e.rf_center_hz,\r\n\r\n            \"lo1_hz\": lo1.freq_hz,\r\n            \"lo1_mode\": lo1.mode,\r\n            \"lo1_vco_div\": 1,\r\n            \"lo1_drive_dbm\": lo1.delivered_power_dbm,\r\n            \"lo1_pad_db\": lo1.pad_db,\r\n            \"lo1_side\": side,\r\n\r\n            \"lo2_hz\": lo2.freq_hz,\r\n            \"lo2_mode\": lo2.mode,\r\n            \"lo2_vco_div\": 1,\r\n            \"lo2_drive_dbm\": lo2.delivered_power_dbm,\r\n            \"lo2_pad_db\": lo2.pad_db,\r\n            \"lo2_side\": side,\r\n\r\n            \"spur_margin_db\": e.spur_margin_db,\r\n            \"margin\": e.spur_margin_db,  # deprecated alias\r\n\r\n            \"brittleness_db_per_step\": e.brittleness_db_per_step,\r\n            \"lock_time_ms_tile\": e.lock_time_ms_tile,\r\n\r\n            \"if2_center_hz\": if2_filter.center_hz,\r\n            \"if2_bw_hz\": if2_filter.bw_hz,\r\n            \"if2_model_type\": (\r\n                \"symmetric_powerlaw\" if if2_filter.model_type == 0\r\n                else \"scaled_s2p_prototype\"\r\n            ),\r\n\r\n            \"rf_bpf_id\": getattr(hw_stack, \"rf_bpf_id\", \"rf_bpf_synthetic\"),\r\n\r\n            \"desired_stage1_tuple\": s1_tup,\r\n            \"desired_stage2_tuple\": s2_tup,\r\n            \"notes\": \"\",\r\n        })\r\n\r\n    return pd.DataFrame(rows)\r\n\r\n\r\ndef sha256_file(path):\r\n    try:\r\n        with open(path, \"rb\") as f:\r\n            return hashlib.sha256(f.read()).hexdigest()\r\n    except Exception:\r\n        return None\r\n\r\n\r\ndef export_metadata(cfg, best_global, out_dir: Path):\r\n    if2 = best_global['if2_model']\r\n    stack_def = best_global['stack_def']\r\n\r\n    final_policy_path = out_dir / \"final_policy.csv\"\r\n\r\n    meta = {\r\n        \"project\": cfg.yaml_data.get(\"project\", {}),\r\n        \"seed\": cfg.yaml_data.get(\"project\", {}).get(\"seed\", None),\r\n        \"grid\": {\r\n            \"grid_step_hz\": cfg.grid_step_hz,\r\n            \"rbw_hz\": cfg.rbw_hz,\r\n            \"grid_max_freq_hz\": cfg.grid_max_freq_hz,\r\n        },\r\n        \"orders\": {\r\n            \"m1_max_order\": cfg.m1_max_order,\r\n            \"m2_max_order\": cfg.m2_max_order,\r\n            \"cross_stage_sum_max\": cfg.cross_stage_sum_max,\r\n        },\r\n        \"hardware\": {\r\n            \"stack_name\": stack_def.get(\"name\"),\r\n            \"rf_bpf_file\": stack_def.get(\"rf_bpf_file\"),\r\n        },\r\n        \"runtime\": {\r\n            \"max_spur_level_dbc\": cfg.max_spur_level_dbc,\r\n            \"dominant_prune_cutoff_db\": cfg.dominant_prune_cutoff_db,\r\n        },\r\n        \"files\": {\r\n            \"config_yaml_sha256\": sha256_file(\"config.yaml\"),\r\n            \"final_policy_sha256\": sha256_file(final_policy_path),\r\n        },\r\n        \"if2_selected\": {\r\n            \"center_hz\": if2.center_hz,\r\n            \"bw_hz\": if2.bw_hz,\r\n        },\r\n        \"python\": sys.version,\r\n        \"platform\": platform.platform(),\r\n    }\r\n\r\n    meta_path = out_dir / \"run_metadata.json\"\r\n    with open(meta_path, \"w\") as f:\r\n        json.dump(meta, f, indent=2)\r\n    print(f\"Run metadata written to {meta_path}\")\r\n\r\n\r\ndef main():\r\n    print(f\"{Fore.CYAN}=== Dual-Conversion BUC Spur Optimizer (Accelerated) ==={Style.RESET_ALL}\")\r\n    try:\r\n        cfg = GlobalConfig.load(\"config.yaml\")\r\n        seed = cfg.yaml_data['project'].get('seed', 42)\r\n        np.random.seed(seed)\r\n    except Exception as e:\r\n        print(f\"{Fore.RED}Error loading configuration:{Style.RESET_ALL} {e}\")\r\n        return\r\n\r\n    # NEW: Set up output directory at project root\r\n    out_dir = Path(__file__).parent / \"out\"\r\n    out_dir.mkdir(exist_ok=True)\r\n    print(f\"Outputs will be written to: {out_dir}\")\r\n\r\n    stacks = cfg.yaml_data['hardware_choices']['stacks']\r\n    all_global_results = []\r\n    num_workers = max(1, cpu_count() - 1)\r\n    TOP_K_SEEDS = cfg.yaml_data['if2_model']['search'].get('top_k_seeds_for_refinement', 3)\r\n\r\n    for stack_def in stacks:\r\n        print(f\"\\nEvaluating Hardware Stack: {Fore.GREEN}{stack_def['name']}{Style.RESET_ALL}\")\r\n        if2_cfg = cfg.yaml_data['if2_model']\r\n        ftype = 1 if (if2_cfg.get('scaled_s2p', {}).get('enabled', False)) else 0\r\n\r\n        # Force everything to float to avoid StrDType issues from YAML\r\n        c_min, c_max = if2_cfg['center_range_hz']\r\n        c_min = float(c_min)\r\n        c_max = float(c_max)\r\n        center_step = float(if2_cfg['search']['coarse_center_step_hz'])\r\n\r\n        bw_min = float(if2_cfg['min_bw_hz'])\r\n        bw_max = float(if2_cfg['max_bw_hz'])\r\n        bw_step = float(if2_cfg['search']['coarse_bw_step_hz'])\r\n\r\n        centers = np.arange(c_min, c_max, center_step, dtype=float)\r\n        bws     = np.arange(bw_min, bw_max, bw_step, dtype=float)\r\n\r\n        tasks = []\r\n        for c in centers:\r\n            for bw in bws:\r\n                tasks.append(FilterModel(\r\n                    c, bw, ftype, if2_cfg['passband_il_db'],\r\n                    if2_cfg['rolloff_db_per_dec'], if2_cfg['stop_floor_db']\r\n                ))\r\n\r\n        total_tasks = len(tasks)\r\n        print(f\"  Scanning {total_tasks} coarse points with {num_workers} workers...\")\r\n        tasks.sort(key=lambda x: (x.center_hz, x.bw_hz))\r\n\r\n        # Multiprocessing with live progress bar\r\n        with Pool(num_workers, initializer=init_worker, initargs=(cfg, stack_def)) as p:\r\n            results = []\r\n            # Use imap_unordered so we get results as they complete\r\n            for i, res in enumerate(p.imap_unordered(evaluate_wrapper, tasks), 1):\r\n                results.append(res)\r\n\r\n                # Throttle updates for huge grids: roughly 100 updates max\r\n                if (\r\n                    total_tasks <= 200\r\n                    or i == total_tasks\r\n                    or i % max(1, total_tasks // 100) == 0\r\n                ):\r\n                    print_progress(\r\n                        i,\r\n                        total_tasks,\r\n                        prefix=\"    \",\r\n                        length=40,\r\n                        color=Fore.GREEN,\r\n                    )\r\n\r\n        #with Pool(num_workers, initializer=init_worker, initargs=(cfg, stack_def)) as p:\r\n        #    results = p.map(evaluate_wrapper, tasks)\r\n\r\n        results.sort(key=lambda x: (x[0], -x[1]), reverse=True)\r\n        top_seeds = results[:TOP_K_SEEDS]\r\n        print(f\"  Top {len(top_seeds)} Coarse Seeds selected for refinement.\")\r\n\r\n        hw = HardwareStack(cfg, stack_def)\r\n        engine = SpurEngine(cfg, hw)\r\n\r\n        for seed_score, seed_time, seed_model in top_seeds:\r\n            if seed_score <= -900:\r\n                continue\r\n            ref_model, ref_score, ref_time, ref_retunes = local_refinement(engine, seed_model, seed_score, seed_time)\r\n            all_global_results.append({\r\n                \"score\": ref_score,\r\n                \"time\": ref_time,\r\n                \"retunes\": ref_retunes,\r\n                \"stack_def\": stack_def,\r\n                \"if2_model\": ref_model\r\n            })\r\n            print(f\"  {Fore.YELLOW}Refined Result: {ref_score:.2f} dB (LockTime: {ref_time:.1f}ms, Retunes: {ref_retunes}){Style.RESET_ALL}\")\r\n\r\n    if not all_global_results:\r\n        print(\"No solution found.\")\r\n        return\r\n\r\n    all_global_results.sort(key=lambda x: (x['score'], -x['time']), reverse=True)\r\n\r\n    unique_globals = []\r\n    seen_centers = []\r\n    for res in all_global_results:\r\n        c_mhz = int(res['if2_model'].center_hz / 1e6)\r\n        if not any(abs(c_mhz - s) < 50 for s in seen_centers):\r\n            unique_globals.append(res)\r\n            seen_centers.append(c_mhz)\r\n        if len(unique_globals) >= 3:\r\n            break\r\n\r\n    # Export Alt Designs\r\n    alt_rows = []\r\n    for rank, res in enumerate(unique_globals, start=1):\r\n        if2 = res['if2_model']\r\n        alt_rows.append({\r\n            \"rank\": rank,\r\n            \"stack_name\": res['stack_def']['name'],\r\n            \"if2_center_hz\": if2.center_hz,\r\n            \"if2_bw_hz\": if2.bw_hz,\r\n            \"score_db\": res['score'],\r\n            \"lock_time_ms\": res['time'],\r\n        })\r\n    alt_path = out_dir / \"alt_global_designs.csv\"\r\n    pd.DataFrame(alt_rows).to_csv(alt_path, index=False)\r\n    print(f\"Alternative global designs written to {alt_path}\")\r\n\r\n    best_global = unique_globals[0]\r\n    print(f\"\\n{Fore.YELLOW}=== Final Selected Config ==={Style.RESET_ALL}\")\r\n    print(f\"Score: {best_global['score']:.2f} dB, LockTime: {best_global['time']:.1f}ms\")\r\n\r\n    stack_def = best_global['stack_def']\r\n    final_if2 = best_global['if2_model']\r\n    hw = HardwareStack(cfg, stack_def)\r\n    engine = SpurEngine(cfg, hw)\r\n\r\n    # Re-build policy with no early exit and brittleness on\r\n    print(\"Generating final policy...\")\r\n    _, _, _, entries = engine.build_policy_for_if2(\r\n        final_if2,\r\n        search_mode=False,\r\n        compute_brittleness=True,\r\n        stop_if_margin_below=None\r\n    )\r\n\r\n    df_policy = build_policy_df_from_entries(entries, final_if2, hw, cfg)\r\n    policy_path = out_dir / \"final_policy.csv\"\r\n    df_policy.to_csv(policy_path, index=False)\r\n    print(f\"Final policy written to {policy_path}\")\r\n\r\n    heatmap_path = out_dir / \"heatmap_margin.png\"\r\n    plot_margin_heatmap(df_policy, filename=str(heatmap_path))\r\n    \r\n    # --- Export and plot final IF2 filter attenuation ---\r\n    if2_csv_path = out_dir / \"if2_filter_response.csv\"\r\n    if2_png_path = out_dir / \"if2_filter_response.png\"\r\n    plot_if2_filter(engine, final_if2,\r\n                    csv_path=str(if2_csv_path),\r\n                    png_path=str(if2_png_path))\r\n\r\n    if cfg.markov_matrix.size > 0:\r\n        markov_path = out_dir / \"markov_lock_summary.json\"\r\n        markov_lock_summary(df_policy, cfg.markov_matrix, out_path=str(markov_path))\r\n\r\n    basic_validation(cfg, stack_def, final_if2)\r\n\r\n    valid_rows = df_policy[df_policy['spur_margin_db'] > -900]\r\n    if not valid_rows.empty:\r\n        worst_row = valid_rows.loc[valid_rows['spur_margin_db'].idxmin()]\r\n        print(f\"\\nRunning Diagnostics for Worst Case: Tile {worst_row['tile_id']} (Margin {worst_row['spur_margin_db']:.2f} dB)\")\r\n\r\n        ledger = generate_spur_ledger(engine, int(worst_row['tile_id']), worst_row, final_if2, report_threshold_db=1e9)\r\n        if not ledger.empty:\r\n            print(ledger.head(10).to_string(index=False))\r\n            ledger_path = out_dir / \"worst_case_ledger.csv\"\r\n            ledger.to_csv(ledger_path, index=False)\r\n            print(f\"Worst-case ledger written to {ledger_path}\")\r\n\r\n    export_metadata(cfg, best_global, out_dir)\r\n\r\n\r\nif __name__ == \"__main__\":\r\n    main()\r\n",
      "encoding": "utf-8",
      "encoding_error": false
    },
    {
      "type": "file",
      "name": "pyproject.toml",
      "path": "pyproject.toml",
      "size": 549,
      "content_truncated": false,
      "contents": "[project]\r\nname = \"bucso2-repo\"\r\nversion = \"0.1.0\"\r\ndescription = \"Add your description here\"\r\nreadme = \"README.md\"\r\nrequires-python = \">=3.13\"\r\ndependencies = [\r\n    \"colorama>=0.4.6\",\r\n    \"matplotlib>=3.10.7\",\r\n    \"numba>=0.62.1\",\r\n    \"numpy>=2.3.5\",\r\n    \"pandas>=2.3.3\",\r\n    \"pytest>=9.0.1\",\r\n    \"pyyaml>=6.0.3\",\r\n    \"scipy>=1.16.3\",\r\n]\r\n\r\n[tool.pytest.ini_options]\r\ntestpaths = [\"tests\"]\r\n\r\n[build-system]\r\nrequires = [\"setuptools>=69\", \"wheel\"]\r\nbuild-backend = \"setuptools.build_meta\"\r\n\r\n[tool.setuptools.packages.find]\r\nwhere = [\"src\"]",
      "encoding": "utf-8",
      "encoding_error": false
    },
    {
      "type": "file",
      "name": "README.md",
      "path": "README.md",
      "size": 0,
      "content_truncated": false,
      "contents": "",
      "encoding": "utf-8",
      "encoding_error": false
    },
    {
      "type": "file",
      "name": "RF_S21_28to31GHz.csv",
      "path": "RF_S21_28to31GHz.csv",
      "size": 1851,
      "content_truncated": false,
      "contents": "23.4e+9,-80.0\r\n23.5e+9,-57.7\r\n23.6e+9,-54.3\r\n23.7e+9,-52.6\r\n23.8e+9,-53.3\r\n23.9e+9,-51.3\r\n24.0e+9,-49.6\r\n24.1e+9,-49.6\r\n24.2e+9,-51.6\r\n24.3e+9,-51.6\r\n24.4e+9,-50.3\r\n24.5e+9,-54.1\r\n24.6e+9,-52.0\r\n24.7e+9,-50.6\r\n24.8e+9,-50.0\r\n24.9e+9,-51.3\r\n25.0e+9,-51.0\r\n25.1e+9,-50.6\r\n25.2e+9,-48.3\r\n25.3e+9,-47.0\r\n25.4e+9,-46.1\r\n25.5e+9,-44.5\r\n25.6e+9,-43.6\r\n25.7e+9,-42.7\r\n25.8e+9,-41.0\r\n25.9e+9,-38.3\r\n26.0e+9,-35.6\r\n26.1e+9,-32.6\r\n26.2e+9,-29.8\r\n26.3e+9,-27.1\r\n26.4e+9,-23.5\r\n26.5e+9,-19.9\r\n26.6e+9,-16.2\r\n26.7e+9,-12.4\r\n26.8e+9,-8.4\r\n26.9e+9,-4.7\r\n27.0e+9,-2.6\r\n27.1e+9,-1.5\r\n27.2e+9,-1.3\r\n27.3e+9,-1.1\r\n27.4e+9,-1.0\r\n27.5e+9,-0.9\r\n27.6e+9,-0.8\r\n27.7e+9,-0.8\r\n27.8e+9,-0.8\r\n27.9e+9,-0.8\r\n28.0e+9,-0.8\r\n28.1e+9,-0.7\r\n28.2e+9,-0.7\r\n28.3e+9,-0.7\r\n28.4e+9,-0.7\r\n28.5e+9,-0.7\r\n28.6e+9,-0.7\r\n28.7e+9,-0.7\r\n28.8e+9,-0.5\r\n28.9e+9,-0.5\r\n29.0e+9,-0.5\r\n29.1e+9,-0.5\r\n29.2e+9,-0.7\r\n29.3e+9,-0.7\r\n29.4e+9,-0.7\r\n29.5e+9,-0.7\r\n29.6e+9,-0.7\r\n29.7e+9,-0.7\r\n29.8e+9,-0.7\r\n29.9e+9,-0.7\r\n30.0e+9,-0.7\r\n30.1e+9,-0.7\r\n30.2e+9,-0.7\r\n30.3e+9,-0.7\r\n30.4e+9,-0.7\r\n30.5e+9,-0.7\r\n30.6e+9,-0.8\r\n30.7e+9,-0.7\r\n30.8e+9,-0.7\r\n30.9e+9,-0.8\r\n31.0e+9,-0.8\r\n31.1e+9,-0.8\r\n31.2e+9,-0.9\r\n31.3e+9,-1.0\r\n31.4e+9,-1.2\r\n31.5e+9,-1.3\r\n31.6e+9,-1.6\r\n31.7e+9,-2.4\r\n31.8e+9,-4.4\r\n31.9e+9,-7.2\r\n32.0e+9,-10.6\r\n32.1e+9,-13.8\r\n32.2e+9,-17.7\r\n32.3e+9,-20.3\r\n32.4e+9,-23.2\r\n32.5e+9,-25.7\r\n32.6e+9,-28.2\r\n32.7e+9,-30.5\r\n32.8e+9,-32.7\r\n32.9e+9,-34.6\r\n33.0e+9,-36.1\r\n33.1e+9,-38.0\r\n33.2e+9,-39.2\r\n33.3e+9,-40.7\r\n33.4e+9,-41.9\r\n33.5e+9,-43.4\r\n33.6e+9,-45.1\r\n33.7e+9,-46.2\r\n33.8e+9,-47.1\r\n33.9e+9,-47.6\r\n34.0e+9,-49.4\r\n34.1e+9,-50.2\r\n34.2e+9,-52.4\r\n34.3e+9,-52.2\r\n34.4e+9,-50.9\r\n34.5e+9,-53.6\r\n34.6e+9,-52.6\r\n34.7e+9,-52.4\r\n34.8e+9,-52.1\r\n34.9e+9,-52.0\r\n35.0e+9,-51.6\r\n35.1e+9,-50.3\r\n35.2e+9,-49.7\r\n35.3e+9,-49.9\r\n35.4e+9,-50.5\r\n35.5e+9,-50.4\r\n35.6e+9,-51.2\r\n35.7e+9,-49.1\r\n35.8e+9,-48.4\r\n35.9e+9,-47.8\r\n36.0e+9,-80.0",
      "encoding": "utf-8",
      "encoding_error": false
    }
  ]
}